<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adventure Mode - Austin's Dragon Lair</title>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        body {
            background-image: url('images/header.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-repeat: no-repeat;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.2);
            z-index: -1;
        }

        @media screen and (max-width: 768px) {
            body {
                background-attachment: scroll;
            }
        }

        main {
            position: relative;
            z-index: 1;
        }

        .story-container {
            max-width: 1400px;
            margin: 10px auto;
            padding: 10px;
            position: relative;
            z-index: 1;
        }

        .story-header {
            text-align: center;
            margin-bottom: 15px;
        }

        .story-header h1 {
            color: #FFD700;
            font-size: 32px;
            margin: 5px 0;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .story-header p {
            color: #E0E0E0;
            font-size: 16px;
            margin: 5px 0;
        }

        .story-arena {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .story-side {
            flex: 1;
            max-width: 500px;
            min-width: 300px;
        }

        .story-side h2 {
            text-align: center;
            color: #FFD700;
            font-size: 20px;
            margin-bottom: 10px;
        }

        .dragon-selector {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            background-color: #1a1a1a;
            color: #FFFFFF;
            border: 2px solid #8844AA;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .dragon-selector:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .selected-dragon {
            background-color: #1a1a1a;
            border: 3px solid #8844AA;
            border-radius: 10px;
            padding: 10px;
            margin-top: 10px;
        }

        @media screen and (max-width: 768px) {
            .selected-dragon {
                border-width: 2px;
                border-radius: 6px;
            }
        }

        .selected-dragon img {
            width: 100%;
            max-width: 250px;
            border: 2px solid #8844AA;
            border-radius: 8px;
            margin: 10px auto;
            display: block;
        }

        .selected-dragon h3 {
            color: #FFD700;
            font-size: 18px;
            text-align: center;
            margin: 10px 0 5px 0;
        }

        .selected-dragon .element {
            text-align: center;
            font-size: 14px;
            margin: 5px 0;
            font-weight: bold;
        }

        .selected-dragon h4 {
            color: #66B3FF;
            font-size: 16px;
            margin-top: 15px;
            margin-bottom: 8px;
        }

        .selected-dragon ol {
            color: #E0E0E0;
            line-height: 1.4;
            padding-left: 20px;
            font-size: 12px;
        }

        .selected-dragon ol li {
            margin-bottom: 5px;
        }

        .story-button-container {
            text-align: center;
            margin: 15px 0;
            background-color: transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .story-start-button {
            background-color: #8844AA !important;
            color: #FFFFFF !important;
            font-size: 18px;
            font-weight: bold;
            padding: 12px 30px;
            border: 3px solid #AA66CC !important;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(136, 68, 170, 0.4);
            opacity: 1 !important;
            text-decoration: none;
            display: inline-block;
        }

        .story-start-button:hover {
            background-color: #6644AA;
            box-shadow: 0 6px 12px rgba(136, 68, 170, 0.6);
            transform: translateY(-2px);
        }

        .story-start-button:disabled {
            background-color: #666666;
            border-color: #888888;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .back-link-container {
            text-align: center;
            margin-top: 15px;
        }

        .back-link {
            color: #FFFFFF;
            font-size: 14px;
            text-decoration: none;
            background-color: #66AAFF;
            border: 2px solid #88CCFF;
            padding: 8px 20px;
            border-radius: 8px;
            display: inline-block;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(102, 170, 255, 0.4);
        }

        .back-link:hover {
            background-color: #4488FF;
            border-color: #66AAFF;
            box-shadow: 0 4px 8px rgba(102, 170, 255, 0.6);
            transform: translateY(-2px);
        }

        /* Element-specific colors for selected dragons */
        .selected-dragon.fire { border-color: #FF4444; }
        .selected-dragon.fire h3 { color: #FF6666; }
        .selected-dragon.fire .element { color: #FF6666; }
        .selected-dragon.fire img { border-color: #FF4444; }

        .selected-dragon.water { border-color: #4488FF; }
        .selected-dragon.water h3 { color: #66AAFF; }
        .selected-dragon.water .element { color: #66AAFF; }
        .selected-dragon.water img { border-color: #4488FF; }

        .selected-dragon.lightning { border-color: #FFDD00; }
        .selected-dragon.lightning h3 { color: #FFEE44; }
        .selected-dragon.lightning .element { color: #FFEE44; }
        .selected-dragon.lightning img { border-color: #FFDD00; }

        .selected-dragon.earth { border-color: #8B6F47; }
        .selected-dragon.earth h3 { color: #CCAA66; }
        .selected-dragon.earth .element { color: #CCAA66; }
        .selected-dragon.earth img { border-color: #8B6F47; }

        .selected-dragon.air { border-color: #88CCFF; }
        .selected-dragon.air h3 { color: #AAEEFF; }
        .selected-dragon.air .element { color: #AAEEFF; }
        .selected-dragon.air img { border-color: #88CCFF; }

        .selected-dragon.ice { border-color: #88EEFF; }
        .selected-dragon.ice h3 { color: #AAFFFF; }
        .selected-dragon.ice .element { color: #AAFFFF; }
        .selected-dragon.ice img { border-color: #88EEFF; }

        .selected-dragon.shadow { border-color: #8844AA; }
        .selected-dragon.shadow h3 { color: #BB88DD; }
        .selected-dragon.shadow .element { color: #BB88DD; }
        .selected-dragon.shadow img { border-color: #8844AA; }

        .selected-dragon.light { border-color: #FFD700; }
        .selected-dragon.light h3 { color: #FFEE88; }
        .selected-dragon.light .element { color: #FFEE88; }
        .selected-dragon.light img { border-color: #FFD700; }

        .selected-dragon.nature { border-color: #44AA44; }
        .selected-dragon.nature h3 { color: #66DD66; }
        .selected-dragon.nature .element { color: #66DD66; }
        .selected-dragon.nature img { border-color: #44AA44; }

        .selected-dragon.metal { border-color: #AAAAAA; }
        .selected-dragon.metal h3 { color: #DDDDDD; }
        .selected-dragon.metal .element { color: #DDDDDD; }
        .selected-dragon.metal img { border-color: #AAAAAA; }

        .selected-dragon.crystal { border-color: #BB66FF; }
        .selected-dragon.crystal h3 { color: #DD99FF; }
        .selected-dragon.crystal .element { color: #DD99FF; }
        .selected-dragon.crystal img { border-color: #BB66FF; }

        .selected-dragon.chaos { border-color: #FF44AA; }
        .selected-dragon.chaos h3 { color: #FF88DD; }
        .selected-dragon.chaos .element { color: #FF88DD; }
        .selected-dragon.chaos img { border-color: #FF44AA; }

        /* Selection Area Visibility */
        .selection-area {
            display: block;
        }

        .selection-area.hidden {
            display: none;
        }

        /* Adventure Game View Styles */
        .adventure-view {
            display: none;
        }

        .adventure-view.active {
            display: block !important;
            visibility: visible !important;
        }

        .cave-container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: linear-gradient(180deg, #2a2a3e 0%, #1f2a3e 50%, #1a1a2e 100%);
            border: 4px solid #5a5a7a;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8), inset 0 0 50px rgba(0, 0, 0, 0.5);
            position: relative;
            min-height: 560px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            display: block;
            visibility: visible;
        }

        .cave-background {
            width: 100%;
            height: 500px;
            min-height: 500px;
            background: 
                repeating-linear-gradient(90deg, 
                    #3a3a4e 0px, #3a3a4e 16px,
                    #2a2a3e 16px, #2a2a3e 32px),
                repeating-linear-gradient(0deg,
                    #4a4a5e 0px, #4a4a5e 16px,
                    #3a3a4e 16px, #3a3a4e 32px),
                radial-gradient(ellipse at top, #5a5a6e 0%, transparent 50%);
            background-color: #2a2a3e;
            border-radius: 10px;
            position: relative;
            overflow: visible;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border: 3px solid #6a6a8a;
            display: block;
            visibility: visible;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
            padding: 20px;
            box-sizing: border-box;
            z-index: 1;
        }
        
        /* Ensure pixel-dragon is always visible when inside cave-background */
        .cave-background .pixel-dragon {
            position: absolute !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Obstacle styles */
        .obstacle {
            position: absolute;
            background-color: #5a5a7a;
            border: 3px solid #8a8aaa;
            border-radius: 8px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5), 0 2px 6px rgba(0, 0, 0, 0.3);
            z-index: 50;
            image-rendering: pixelated;
        }

        .obstacle.rock {
            background: linear-gradient(135deg, #6a6a7a 0%, #4a4a5a 100%);
            border-color: #8a8a9a;
        }

        .obstacle.crystal {
            background: linear-gradient(135deg, #7a6a9a 0%, #5a4a7a 100%);
            border-color: #9a8aaa;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5), 0 2px 6px rgba(0, 0, 0, 0.3), 0 0 10px rgba(187, 136, 221, 0.3);
        }

        .obstacle.stalagmite {
            background: linear-gradient(180deg, #7a7a8a 0%, #3a3a4a 100%);
            border-color: #6a6a7a;
            clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
        }

        /* Teleport to Main Room Button */
        .teleport-main-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, #FFD700 0%, #FFAA00 100%);
            color: #000000;
            font-size: 14px;
            font-weight: bold;
            padding: 10px 20px;
            border: 3px solid #FFEE88;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.6), 0 0 20px rgba(255, 215, 0, 0.4);
            z-index: 200;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: Arial, sans-serif;
        }

        .teleport-main-button:hover {
            background: linear-gradient(135deg, #FFEE44 0%, #FFD700 100%);
            box-shadow: 0 6px 16px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 215, 0, 0.6);
            transform: scale(1.05);
        }

        .teleport-main-button:active {
            transform: scale(0.95);
        }

        @media screen and (max-width: 768px) {
            .teleport-main-button {
                font-size: 12px;
                padding: 8px 15px;
                top: 10px;
                right: 10px;
            }
        }

        .cave-stalactites {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background-image: 
                repeating-linear-gradient(90deg,
                    transparent 0px, transparent 40px,
                    rgba(0,0,0,0.4) 40px, rgba(0,0,0,0.4) 80px);
            pointer-events: none;
            clip-path: polygon(0% 0%, 10% 100%, 20% 0%, 30% 100%, 40% 0%, 50% 100%, 60% 0%, 70% 100%, 80% 0%, 90% 100%, 100% 0%);
        }

        .pixel-dragon {
            position: absolute !important;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            transition: none;
            z-index: 100;
            width: 80px !important;
            height: 80px !important;
            object-fit: contain !important;
            visibility: visible !important;
            display: block !important;
            opacity: 1 !important;
            border: none !important;
            background: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            margin: 0 !important;
            overflow: hidden !important;
        }

        /* Override all dragon-specific classes to ensure uniform size and appearance */
        .pixel-dragon.breezeflight,
        .pixel-dragon.chaosflare,
        .pixel-dragon.crystalwing,
        .pixel-dragon.earthheart,
        .pixel-dragon.flamethorn,
        .pixel-dragon.frostbite,
        .pixel-dragon.radiant,
        .pixel-dragon.stormwing,
        .pixel-dragon.metalbeak,
        .pixel-dragon.vineclaw,
        .pixel-dragon.shadowmaw,
        .pixel-dragon.aquaris {
            width: 80px !important;
            height: 80px !important;
            border: none !important;
            background: none !important;
            box-shadow: none !important;
            object-fit: contain !important;
            overflow: hidden !important;
        }

        /* Hide pseudo-elements (::before and ::after) since we're using images now */
        .pixel-dragon.breezeflight::before,
        .pixel-dragon.chaosflare::before,
        .pixel-dragon.crystalwing::before,
        .pixel-dragon.earthheart::before,
        .pixel-dragon.flamethorn::before,
        .pixel-dragon.frostbite::before,
        .pixel-dragon.radiant::before,
        .pixel-dragon.stormwing::before,
        .pixel-dragon.metalbeak::before,
        .pixel-dragon.vineclaw::before,
        .pixel-dragon.shadowmaw::before,
        .pixel-dragon.aquaris::before,
        .pixel-dragon.breezeflight::after,
        .pixel-dragon.chaosflare::after,
        .pixel-dragon.crystalwing::after,
        .pixel-dragon.earthheart::after,
        .pixel-dragon.flamethorn::after,
        .pixel-dragon.frostbite::after,
        .pixel-dragon.radiant::after,
        .pixel-dragon.stormwing::after,
        .pixel-dragon.metalbeak::after,
        .pixel-dragon.vineclaw::after,
        .pixel-dragon.shadowmaw::after,
        .pixel-dragon.aquaris::after {
            display: none !important;
            content: none !important;
        }

        /* Pixelated Dragon Sprites - Each dragon gets a unique pixelated design */
        .pixel-dragon.breezeflight {
            background: #A8D4E8 !important;
            width: 50px;
            height: 70px;
            border: 2px solid #88CCFF;
            position: relative;
            overflow: visible;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: 
                /* Detailed body scales - creating scale pattern */
                8px 8px 0 0 #C8E4F0,
                12px 10px 0 0 #E8F4F8,
                18px 12px 0 0 #C8E4F0,
                22px 14px 0 0 #E8F4F8,
                28px 16px 0 0 #C8E4F0,
                32px 18px 0 0 #E8F4F8,
                38px 20px 0 0 #C8E4F0,
                /* Second row of scales */
                10px 18px 0 0 #C8E4F0,
                16px 20px 0 0 #E8F4F8,
                24px 22px 0 0 #C8E4F0,
                30px 24px 0 0 #E8F4F8,
                36px 26px 0 0 #C8E4F0,
                /* Third row */
                12px 28px 0 0 #C8E4F0,
                20px 30px 0 0 #E8F4F8,
                28px 32px 0 0 #C8E4F0,
                34px 34px 0 0 #E8F4F8,
                /* Spine/back ridge */
                20px 5px 0 0 #88CCFF,
                22px 8px 0 0 #66AAFF,
                24px 12px 0 0 #88CCFF,
                26px 16px 0 0 #66AAFF,
                28px 20px 0 0 #88CCFF,
                30px 24px 0 0 #66AAFF,
                32px 28px 0 0 #88CCFF,
                /* Front legs with claws */
                3px 58px 0 0 #A8D4E8,
                3px 62px 0 0 #A8D4E8,
                3px 66px 0 0 #88CCFF,
                7px 58px 0 0 #A8D4E8,
                7px 62px 0 0 #A8D4E8,
                7px 66px 0 0 #88CCFF,
                11px 58px 0 0 #A8D4E8,
                11px 62px 0 0 #A8D4E8,
                /* Back legs with claws */
                33px 58px 0 0 #A8D4E8,
                33px 62px 0 0 #A8D4E8,
                33px 66px 0 0 #88CCFF,
                37px 58px 0 0 #A8D4E8,
                37px 62px 0 0 #A8D4E8,
                37px 66px 0 0 #88CCFF,
                41px 58px 0 0 #A8D4E8,
                41px 62px 0 0 #A8D4E8,
                /* Detailed tail with segments and tip */
                45px 48px 0 0 #A8D4E8,
                48px 52px 0 0 #C8E4F0,
                51px 56px 0 0 #A8D4E8,
                54px 60px 0 0 #C8E4F0,
                57px 64px 0 0 #A8D4E8,
                60px 68px 0 0 #C8E4F0,
                63px 72px 0 0 #A8D4E8,
                66px 76px 0 0 #88CCFF,
                69px 80px 0 0 #66AAFF,
                0 0 10px rgba(136, 204, 255, 0.5);
        }

        /* Detailed head with snout, nostrils, mouth, and horns */
        .pixel-dragon.breezeflight::before {
            content: '';
            position: absolute;
            top: -30px;
            left: 6px;
            width: 38px;
            height: 35px;
            background: #E8F4F8 !important;
            border: 2px solid #88CCFF;
            clip-path: polygon(12% 0%, 88% 0%, 100% 25%, 98% 50%, 85% 75%, 75% 100%, 25% 100%, 15% 75%, 2% 50%, 0% 25%);
            box-shadow: 
                /* Detailed eyes with highlights */
                10px 10px 0 0 #66AAFF,
                10px 10px 0 2px #88CCFF,
                12px 12px 0 0 #FFFFFF,
                22px 10px 0 0 #66AAFF,
                22px 10px 0 2px #88CCFF,
                24px 12px 0 0 #FFFFFF,
                /* Nostrils */
                12px 18px 0 0 #88CCFF,
                26px 18px 0 0 #88CCFF,
                /* Mouth line */
                14px 22px 0 0 #88CCFF,
                16px 24px 0 0 #88CCFF,
                18px 24px 0 0 #88CCFF,
                20px 24px 0 0 #88CCFF,
                22px 24px 0 0 #88CCFF,
                24px 24px 0 0 #88CCFF,
                26px 22px 0 0 #88CCFF,
                /* Detailed horns/spikes on head */
                4px -6px 0 0 #88CCFF,
                4px -6px 0 2px #66AAFF,
                6px -10px 0 0 #66AAFF,
                32px -6px 0 0 #88CCFF,
                32px -6px 0 2px #66AAFF,
                34px -10px 0 0 #66AAFF,
                /* Additional head details */
                8px 6px 0 0 #C8E4F0,
                30px 6px 0 0 #C8E4F0;
            z-index: 11;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Detailed wings with membrane structure and claws */
        .pixel-dragon.breezeflight::after {
            content: '';
            position: absolute;
            top: 12px;
            left: -28px;
            width: 28px;
            height: 45px;
            background: #C8E4F0 !important;
            border: 2px solid #88CCFF;
            clip-path: polygon(0% 0%, 100% 3%, 98% 25%, 100% 50%, 95% 75%, 85% 95%, 0% 100%, 3% 50%);
            box-shadow: 
                /* Right wing */
                78px 0 0 0 #C8E4F0,
                78px 0 0 2px #88CCFF,
                /* Wing membrane structure - creating finger-like supports */
                4px 12px 0 0 #E8F4F8,
                4px 12px 0 1px #88CCFF,
                8px 18px 0 0 #E8F4F8,
                8px 18px 0 1px #88CCFF,
                12px 24px 0 0 #E8F4F8,
                12px 24px 0 1px #88CCFF,
                16px 30px 0 0 #E8F4F8,
                16px 30px 0 1px #88CCFF,
                20px 36px 0 0 #E8F4F8,
                20px 36px 0 1px #88CCFF,
                /* Right wing membrane */
                82px 12px 0 0 #E8F4F8,
                82px 12px 0 1px #88CCFF,
                86px 18px 0 0 #E8F4F8,
                86px 18px 0 1px #88CCFF,
                90px 24px 0 0 #E8F4F8,
                90px 24px 0 1px #88CCFF,
                94px 30px 0 0 #E8F4F8,
                94px 30px 0 1px #88CCFF,
                98px 36px 0 0 #E8F4F8,
                98px 36px 0 1px #88CCFF,
                /* Wing claws - detailed */
                -2px 40px 0 0 #88CCFF,
                -2px 40px 0 1px #66AAFF,
                0px 42px 0 0 #66AAFF,
                2px 44px 0 0 #88CCFF,
                106px 40px 0 0 #88CCFF,
                106px 40px 0 1px #66AAFF,
                108px 42px 0 0 #66AAFF,
                110px 44px 0 0 #88CCFF;
            z-index: 9;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .pixel-dragon.chaosflare {
            background: #FF44AA !important;
            width: 50px;
            height: 70px;
            border: 2px solid #8844FF;
            position: relative;
            overflow: visible;
            animation: chaosPulse 2s infinite;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: 
                /* Detailed chaotic scales */
                8px 8px 0 0 #FF8844,
                12px 10px 0 0 #8844FF,
                18px 12px 0 0 #FF8844,
                22px 14px 0 0 #8844FF,
                28px 16px 0 0 #FF8844,
                32px 18px 0 0 #8844FF,
                38px 20px 0 0 #FF8844,
                10px 18px 0 0 #8844FF,
                16px 20px 0 0 #FF8844,
                24px 22px 0 0 #8844FF,
                30px 24px 0 0 #FF8844,
                36px 26px 0 0 #8844FF,
                12px 28px 0 0 #FF8844,
                20px 30px 0 0 #8844FF,
                28px 32px 0 0 #FF8844,
                34px 34px 0 0 #8844FF,
                /* Chaotic spine */
                20px 5px 0 0 #FF44AA,
                22px 8px 0 0 #FF8844,
                24px 12px 0 0 #8844FF,
                26px 16px 0 0 #FF44AA,
                28px 20px 0 0 #FF8844,
                30px 24px 0 0 #8844FF,
                32px 28px 0 0 #FF44AA,
                /* Front legs with claws */
                3px 58px 0 0 #FF44AA,
                3px 62px 0 0 #FF44AA,
                3px 66px 0 0 #8844FF,
                7px 58px 0 0 #FF44AA,
                7px 62px 0 0 #FF44AA,
                7px 66px 0 0 #8844FF,
                11px 58px 0 0 #FF44AA,
                11px 62px 0 0 #FF44AA,
                /* Back legs */
                33px 58px 0 0 #FF44AA,
                33px 62px 0 0 #FF44AA,
                33px 66px 0 0 #8844FF,
                37px 58px 0 0 #FF44AA,
                37px 62px 0 0 #FF44AA,
                37px 66px 0 0 #8844FF,
                41px 58px 0 0 #FF44AA,
                41px 62px 0 0 #FF44AA,
                /* Detailed tail */
                45px 48px 0 0 #FF44AA,
                48px 52px 0 0 #FF8844,
                51px 56px 0 0 #8844FF,
                54px 60px 0 0 #FF44AA,
                57px 64px 0 0 #FF8844,
                60px 68px 0 0 #8844FF,
                63px 72px 0 0 #FF44AA,
                66px 76px 0 0 #FF8844,
                69px 80px 0 0 #8844FF,
                0 0 10px rgba(255, 68, 170, 0.5);
        }

        .pixel-dragon.chaosflare::before {
            content: '';
            position: absolute;
            top: -30px;
            left: 6px;
            width: 38px;
            height: 35px;
            background: #8844FF;
            border: 2px solid #FF44AA;
            clip-path: polygon(12% 0%, 88% 0%, 100% 25%, 98% 50%, 85% 75%, 75% 100%, 25% 100%, 15% 75%, 2% 50%, 0% 25%);
            box-shadow: 
                10px 10px 0 0 #FF8844,
                10px 10px 0 2px #FF44AA,
                12px 12px 0 0 #FFFFFF,
                22px 10px 0 0 #FF8844,
                22px 10px 0 2px #FF44AA,
                24px 12px 0 0 #FFFFFF,
                12px 18px 0 0 #FF44AA,
                26px 18px 0 0 #FF44AA,
                14px 22px 0 0 #FF44AA,
                16px 24px 0 0 #FF8844,
                18px 24px 0 0 #8844FF,
                20px 24px 0 0 #FF8844,
                22px 24px 0 0 #8844FF,
                24px 24px 0 0 #FF8844,
                26px 22px 0 0 #FF44AA,
                4px -6px 0 0 #FF44AA,
                4px -6px 0 2px #FF8844,
                6px -10px 0 0 #FF8844,
                32px -6px 0 0 #FF44AA,
                32px -6px 0 2px #FF8844,
                34px -10px 0 0 #FF8844,
                8px 6px 0 0 #FF8844,
                30px 6px 0 0 #8844FF;
            z-index: 1;
            display: block;
        }

        .pixel-dragon.chaosflare::after {
            content: '';
            position: absolute;
            top: 12px;
            left: -28px;
            width: 28px;
            height: 45px;
            background: #FF8844;
            border: 2px solid #FF44AA;
            clip-path: polygon(0% 0%, 100% 3%, 98% 25%, 100% 50%, 95% 75%, 85% 95%, 0% 100%, 3% 50%);
            box-shadow: 
                78px 0 0 0 #FF8844,
                78px 0 0 2px #FF44AA,
                4px 12px 0 0 #8844FF,
                4px 12px 0 1px #FF44AA,
                8px 18px 0 0 #FF44AA,
                8px 18px 0 1px #FF8844,
                12px 24px 0 0 #8844FF,
                12px 24px 0 1px #FF44AA,
                16px 30px 0 0 #FF44AA,
                16px 30px 0 1px #FF8844,
                20px 36px 0 0 #8844FF,
                20px 36px 0 1px #FF44AA,
                82px 12px 0 0 #8844FF,
                82px 12px 0 1px #FF44AA,
                86px 18px 0 0 #FF44AA,
                86px 18px 0 1px #FF8844,
                90px 24px 0 0 #8844FF,
                90px 24px 0 1px #FF44AA,
                94px 30px 0 0 #FF44AA,
                94px 30px 0 1px #FF8844,
                98px 36px 0 0 #8844FF,
                98px 36px 0 1px #FF44AA,
                -2px 40px 0 0 #FF44AA,
                -2px 40px 0 1px #FF8844,
                0px 42px 0 0 #FF8844,
                2px 44px 0 0 #FF44AA,
                106px 40px 0 0 #FF44AA,
                106px 40px 0 1px #FF8844,
                108px 42px 0 0 #FF8844,
                110px 44px 0 0 #FF44AA;
            z-index: 0;
            display: block;
        }

        @keyframes chaosPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }

        .pixel-dragon.crystalwing {
            background: #DD99FF !important;
            width: 50px;
            height: 70px;
            border: 2px solid #BB66FF;
            position: relative;
            overflow: visible;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: 
                /* Detailed crystal scales */
                8px 8px 0 0 #BB66FF,
                12px 10px 0 0 #DD99FF,
                18px 12px 0 0 #BB66FF,
                22px 14px 0 0 #DD99FF,
                28px 16px 0 0 #BB66FF,
                32px 18px 0 0 #DD99FF,
                38px 20px 0 0 #BB66FF,
                10px 18px 0 0 #DD99FF,
                16px 20px 0 0 #BB66FF,
                24px 22px 0 0 #DD99FF,
                30px 24px 0 0 #BB66FF,
                36px 26px 0 0 #DD99FF,
                12px 28px 0 0 #BB66FF,
                20px 30px 0 0 #DD99FF,
                28px 32px 0 0 #BB66FF,
                34px 34px 0 0 #DD99FF,
                /* Crystal spine */
                20px 5px 0 0 #BB66FF,
                22px 8px 0 0 #DD99FF,
                24px 12px 0 0 #BB66FF,
                26px 16px 0 0 #DD99FF,
                28px 20px 0 0 #BB66FF,
                30px 24px 0 0 #DD99FF,
                32px 28px 0 0 #BB66FF,
                /* Front legs with claws */
                3px 58px 0 0 #DD99FF,
                3px 62px 0 0 #DD99FF,
                3px 66px 0 0 #BB66FF,
                7px 58px 0 0 #DD99FF,
                7px 62px 0 0 #DD99FF,
                7px 66px 0 0 #BB66FF,
                11px 58px 0 0 #DD99FF,
                11px 62px 0 0 #DD99FF,
                /* Back legs */
                33px 58px 0 0 #DD99FF,
                33px 62px 0 0 #DD99FF,
                33px 66px 0 0 #BB66FF,
                37px 58px 0 0 #DD99FF,
                37px 62px 0 0 #DD99FF,
                37px 66px 0 0 #BB66FF,
                41px 58px 0 0 #DD99FF,
                41px 62px 0 0 #DD99FF,
                /* Detailed tail */
                45px 48px 0 0 #DD99FF,
                48px 52px 0 0 #BB66FF,
                51px 56px 0 0 #DD99FF,
                54px 60px 0 0 #BB66FF,
                57px 64px 0 0 #DD99FF,
                60px 68px 0 0 #BB66FF,
                63px 72px 0 0 #DD99FF,
                66px 76px 0 0 #BB66FF,
                69px 80px 0 0 #DD99FF,
                0 0 10px rgba(187, 102, 255, 0.5);
        }

        .pixel-dragon.crystalwing::before {
            content: '';
            position: absolute;
            top: -30px;
            left: 6px;
            width: 38px;
            height: 35px;
            background: #BB66FF;
            border: 2px solid #DD99FF;
            clip-path: polygon(12% 0%, 88% 0%, 100% 25%, 98% 50%, 85% 75%, 75% 100%, 25% 100%, 15% 75%, 2% 50%, 0% 25%);
            box-shadow: 
                10px 10px 0 0 #DD99FF,
                10px 10px 0 2px #BB66FF,
                12px 12px 0 0 #FFFFFF,
                22px 10px 0 0 #DD99FF,
                22px 10px 0 2px #BB66FF,
                24px 12px 0 0 #FFFFFF,
                12px 18px 0 0 #DD99FF,
                26px 18px 0 0 #DD99FF,
                14px 22px 0 0 #DD99FF,
                16px 24px 0 0 #BB66FF,
                18px 24px 0 0 #DD99FF,
                20px 24px 0 0 #BB66FF,
                22px 24px 0 0 #DD99FF,
                24px 24px 0 0 #BB66FF,
                26px 22px 0 0 #DD99FF,
                4px -6px 0 0 #DD99FF,
                4px -6px 0 2px #BB66FF,
                6px -10px 0 0 #BB66FF,
                32px -6px 0 0 #DD99FF,
                32px -6px 0 2px #BB66FF,
                34px -10px 0 0 #BB66FF,
                8px 6px 0 0 #DD99FF,
                30px 6px 0 0 #BB66FF;
            z-index: 1;
            display: block;
            filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.5));
        }

        .pixel-dragon.crystalwing::after {
            content: '';
            position: absolute;
            top: 12px;
            left: -28px;
            width: 28px;
            height: 45px;
            background: #BB66FF;
            border: 2px solid #DD99FF;
            clip-path: polygon(0% 0%, 100% 3%, 98% 25%, 100% 50%, 95% 75%, 85% 95%, 0% 100%, 3% 50%);
            box-shadow: 
                78px 0 0 0 #BB66FF,
                78px 0 0 2px #DD99FF,
                4px 12px 0 0 #DD99FF,
                4px 12px 0 1px #BB66FF,
                8px 18px 0 0 #BB66FF,
                8px 18px 0 1px #DD99FF,
                12px 24px 0 0 #DD99FF,
                12px 24px 0 1px #BB66FF,
                16px 30px 0 0 #BB66FF,
                16px 30px 0 1px #DD99FF,
                20px 36px 0 0 #DD99FF,
                20px 36px 0 1px #BB66FF,
                82px 12px 0 0 #DD99FF,
                82px 12px 0 1px #BB66FF,
                86px 18px 0 0 #BB66FF,
                86px 18px 0 1px #DD99FF,
                90px 24px 0 0 #DD99FF,
                90px 24px 0 1px #BB66FF,
                94px 30px 0 0 #BB66FF,
                94px 30px 0 1px #DD99FF,
                98px 36px 0 0 #DD99FF,
                98px 36px 0 1px #BB66FF,
                -2px 40px 0 0 #DD99FF,
                -2px 40px 0 1px #BB66FF,
                0px 42px 0 0 #BB66FF,
                2px 44px 0 0 #DD99FF,
                106px 40px 0 0 #DD99FF,
                106px 40px 0 1px #BB66FF,
                108px 42px 0 0 #BB66FF,
                110px 44px 0 0 #DD99FF;
            z-index: 0;
            display: block;
        }

        .pixel-dragon.earthheart {
            background: #8B6F47 !important;
            width: 50px;
            height: 70px;
            border: 2px solid #5B4F27;
            position: relative;
            overflow: visible;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: 
                /* Detailed stone scales */
                8px 8px 0 0 #6B5F37,
                12px 10px 0 0 #8B6F47,
                18px 12px 0 0 #6B5F37,
                22px 14px 0 0 #8B6F47,
                28px 16px 0 0 #6B5F37,
                32px 18px 0 0 #8B6F47,
                38px 20px 0 0 #6B5F37,
                10px 18px 0 0 #8B6F47,
                16px 20px 0 0 #6B5F37,
                24px 22px 0 0 #8B6F47,
                30px 24px 0 0 #6B5F37,
                36px 26px 0 0 #8B6F47,
                12px 28px 0 0 #6B5F37,
                20px 30px 0 0 #8B6F47,
                28px 32px 0 0 #6B5F37,
                34px 34px 0 0 #8B6F47,
                /* Stone spine */
                20px 5px 0 0 #5B4F27,
                22px 8px 0 0 #6B5F37,
                24px 12px 0 0 #5B4F27,
                26px 16px 0 0 #6B5F37,
                28px 20px 0 0 #5B4F27,
                30px 24px 0 0 #6B5F37,
                32px 28px 0 0 #5B4F27,
                /* Front legs with claws */
                3px 58px 0 0 #8B6F47,
                3px 62px 0 0 #8B6F47,
                3px 66px 0 0 #5B4F27,
                7px 58px 0 0 #8B6F47,
                7px 62px 0 0 #8B6F47,
                7px 66px 0 0 #5B4F27,
                11px 58px 0 0 #8B6F47,
                11px 62px 0 0 #8B6F47,
                /* Back legs */
                33px 58px 0 0 #8B6F47,
                33px 62px 0 0 #8B6F47,
                33px 66px 0 0 #5B4F27,
                37px 58px 0 0 #8B6F47,
                37px 62px 0 0 #8B6F47,
                37px 66px 0 0 #5B4F27,
                41px 58px 0 0 #8B6F47,
                41px 62px 0 0 #8B6F47,
                /* Detailed tail */
                45px 48px 0 0 #8B6F47,
                48px 52px 0 0 #6B5F37,
                51px 56px 0 0 #8B6F47,
                54px 60px 0 0 #6B5F37,
                57px 64px 0 0 #8B6F47,
                60px 68px 0 0 #6B5F37,
                63px 72px 0 0 #8B6F47,
                66px 76px 0 0 #5B4F27,
                69px 80px 0 0 #6B5F37,
                0 0 10px rgba(91, 79, 39, 0.5);
        }

        .pixel-dragon.earthheart::before {
            content: '';
            position: absolute;
            top: -30px;
            left: 6px;
            width: 38px;
            height: 35px;
            background: #6B5F37;
            border: 2px solid #5B4F27;
            clip-path: polygon(12% 0%, 88% 0%, 100% 25%, 98% 50%, 85% 75%, 75% 100%, 25% 100%, 15% 75%, 2% 50%, 0% 25%);
            box-shadow: 
                10px 10px 0 0 #5B4F27,
                10px 10px 0 2px #6B5F37,
                12px 12px 0 0 #FFFFFF,
                22px 10px 0 0 #5B4F27,
                22px 10px 0 2px #6B5F37,
                24px 12px 0 0 #FFFFFF,
                12px 18px 0 0 #5B4F27,
                26px 18px 0 0 #5B4F27,
                14px 22px 0 0 #5B4F27,
                16px 24px 0 0 #8B6F47,
                18px 24px 0 0 #6B5F37,
                20px 24px 0 0 #8B6F47,
                22px 24px 0 0 #6B5F37,
                24px 24px 0 0 #8B6F47,
                26px 22px 0 0 #5B4F27,
                4px -6px 0 0 #5B4F27,
                4px -6px 0 2px #6B5F37,
                6px -10px 0 0 #6B5F37,
                32px -6px 0 0 #5B4F27,
                32px -6px 0 2px #6B5F37,
                34px -10px 0 0 #6B5F37,
                8px 6px 0 0 #8B6F47,
                30px 6px 0 0 #6B5F37;
            z-index: 1;
            display: block;
        }

        .pixel-dragon.earthheart::after {
            content: '';
            position: absolute;
            top: 12px;
            left: -28px;
            width: 28px;
            height: 45px;
            background: #6B5F37;
            border: 2px solid #5B4F27;
            clip-path: polygon(0% 0%, 100% 3%, 98% 25%, 100% 50%, 95% 75%, 85% 95%, 0% 100%, 3% 50%);
            box-shadow: 
                78px 0 0 0 #6B5F37,
                78px 0 0 2px #5B4F27,
                4px 12px 0 0 #8B6F47,
                4px 12px 0 1px #5B4F27,
                8px 18px 0 0 #5B4F27,
                8px 18px 0 1px #6B5F37,
                12px 24px 0 0 #8B6F47,
                12px 24px 0 1px #5B4F27,
                16px 30px 0 0 #5B4F27,
                16px 30px 0 1px #6B5F37,
                20px 36px 0 0 #8B6F47,
                20px 36px 0 1px #5B4F27,
                82px 12px 0 0 #8B6F47,
                82px 12px 0 1px #5B4F27,
                86px 18px 0 0 #5B4F27,
                86px 18px 0 1px #6B5F37,
                90px 24px 0 0 #8B6F47,
                90px 24px 0 1px #5B4F27,
                94px 30px 0 0 #5B4F27,
                94px 30px 0 1px #6B5F37,
                98px 36px 0 0 #8B6F47,
                98px 36px 0 1px #5B4F27,
                -2px 40px 0 0 #5B4F27,
                -2px 40px 0 1px #6B5F37,
                0px 42px 0 0 #6B5F37,
                2px 44px 0 0 #5B4F27,
                106px 40px 0 0 #5B4F27,
                106px 40px 0 1px #6B5F37,
                108px 42px 0 0 #6B5F37,
                110px 44px 0 0 #5B4F27;
            z-index: 0;
            display: block;
        }

        .pixel-dragon.flamethorn {
            background: #FF4444 !important;
            width: 50px;
            height: 70px;
            border: 2px solid #FFD700;
            position: relative;
            overflow: visible;
            animation: fireFlicker 0.5s infinite;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: 
                /* Detailed fire scales */
                8px 8px 0 0 #FF8800,
                12px 10px 0 0 #FFD700,
                18px 12px 0 0 #FF8800,
                22px 14px 0 0 #FFD700,
                28px 16px 0 0 #FF8800,
                32px 18px 0 0 #FFD700,
                38px 20px 0 0 #FF8800,
                10px 18px 0 0 #FFD700,
                16px 20px 0 0 #FF8800,
                24px 22px 0 0 #FFD700,
                30px 24px 0 0 #FF8800,
                36px 26px 0 0 #FFD700,
                12px 28px 0 0 #FF8800,
                20px 30px 0 0 #FFD700,
                28px 32px 0 0 #FF8800,
                34px 34px 0 0 #FFD700,
                /* Fire spine */
                20px 5px 0 0 #FF0000,
                22px 8px 0 0 #FFD700,
                24px 12px 0 0 #FF0000,
                26px 16px 0 0 #FFD700,
                28px 20px 0 0 #FF0000,
                30px 24px 0 0 #FFD700,
                32px 28px 0 0 #FF0000,
                /* Front legs with claws */
                3px 58px 0 0 #FF4444,
                3px 62px 0 0 #FF4444,
                3px 66px 0 0 #FFD700,
                7px 58px 0 0 #FF4444,
                7px 62px 0 0 #FF4444,
                7px 66px 0 0 #FFD700,
                11px 58px 0 0 #FF4444,
                11px 62px 0 0 #FF4444,
                /* Back legs */
                33px 58px 0 0 #FF4444,
                33px 62px 0 0 #FF4444,
                33px 66px 0 0 #FFD700,
                37px 58px 0 0 #FF4444,
                37px 62px 0 0 #FF4444,
                37px 66px 0 0 #FFD700,
                41px 58px 0 0 #FF4444,
                41px 62px 0 0 #FF4444,
                /* Detailed tail */
                45px 48px 0 0 #FF4444,
                48px 52px 0 0 #FF8800,
                51px 56px 0 0 #FF0000,
                54px 60px 0 0 #FF4444,
                57px 64px 0 0 #FF8800,
                60px 68px 0 0 #FF0000,
                63px 72px 0 0 #FF4444,
                66px 76px 0 0 #FF8800,
                69px 80px 0 0 #FFD700,
                0 0 10px rgba(255, 68, 68, 0.5);
        }

        .pixel-dragon.flamethorn::before {
            content: '';
            position: absolute;
            top: -30px;
            left: 6px;
            width: 38px;
            height: 35px;
            background: #FF8800;
            border: 2px solid #FFD700;
            clip-path: polygon(12% 0%, 88% 0%, 100% 25%, 98% 50%, 85% 75%, 75% 100%, 25% 100%, 15% 75%, 2% 50%, 0% 25%);
            box-shadow: 
                10px 10px 0 0 #FFD700,
                10px 10px 0 2px #FF0000,
                12px 12px 0 0 #FFFFFF,
                22px 10px 0 0 #FFD700,
                22px 10px 0 2px #FF0000,
                24px 12px 0 0 #FFFFFF,
                12px 18px 0 0 #FFD700,
                26px 18px 0 0 #FFD700,
                14px 22px 0 0 #FFD700,
                16px 24px 0 0 #FF8800,
                18px 24px 0 0 #FF4444,
                20px 24px 0 0 #FF8800,
                22px 24px 0 0 #FF4444,
                24px 24px 0 0 #FF8800,
                26px 22px 0 0 #FFD700,
                4px -6px 0 0 #FFD700,
                4px -6px 0 2px #FF8800,
                6px -10px 0 0 #FF8800,
                32px -6px 0 0 #FFD700,
                32px -6px 0 2px #FF8800,
                34px -10px 0 0 #FF8800,
                8px 6px 0 0 #FF8800,
                30px 6px 0 0 #FF4444;
            z-index: 1;
            display: block;
            animation: fireFlicker 0.3s infinite;
        }

        .pixel-dragon.flamethorn::after {
            content: '';
            position: absolute;
            top: 12px;
            left: -28px;
            width: 28px;
            height: 45px;
            background: #FF8800;
            border: 2px solid #FFD700;
            clip-path: polygon(0% 0%, 100% 3%, 98% 25%, 100% 50%, 95% 75%, 85% 95%, 0% 100%, 3% 50%);
            box-shadow: 
                78px 0 0 0 #FF8800,
                78px 0 0 2px #FFD700,
                4px 12px 0 0 #FF4444,
                4px 12px 0 1px #FFD700,
                8px 18px 0 0 #FFD700,
                8px 18px 0 1px #FF8800,
                12px 24px 0 0 #FF4444,
                12px 24px 0 1px #FFD700,
                16px 30px 0 0 #FFD700,
                16px 30px 0 1px #FF8800,
                20px 36px 0 0 #FF4444,
                20px 36px 0 1px #FFD700,
                82px 12px 0 0 #FF4444,
                82px 12px 0 1px #FFD700,
                86px 18px 0 0 #FFD700,
                86px 18px 0 1px #FF8800,
                90px 24px 0 0 #FF4444,
                90px 24px 0 1px #FFD700,
                94px 30px 0 0 #FFD700,
                94px 30px 0 1px #FF8800,
                98px 36px 0 0 #FF4444,
                98px 36px 0 1px #FFD700,
                -2px 40px 0 0 #FFD700,
                -2px 40px 0 1px #FF8800,
                0px 42px 0 0 #FF8800,
                2px 44px 0 0 #FFD700,
                106px 40px 0 0 #FFD700,
                106px 40px 0 1px #FF8800,
                108px 42px 0 0 #FF8800,
                110px 44px 0 0 #FFD700;
            z-index: 0;
            display: block;
        }

        @keyframes fireFlicker {
            0%, 100% { box-shadow: 0 0 30px rgba(255, 68, 68, 0.8), 0 0 60px rgba(255, 136, 0, 0.6); }
            50% { box-shadow: 0 0 40px rgba(255, 136, 0, 1), 0 0 80px rgba(255, 200, 0, 0.8); }
        }

        .pixel-dragon.frostbite {
            background: #88EEFF !important;
            width: 50px;
            height: 70px;
            border: 2px solid #66CCFF;
            position: relative;
            overflow: visible;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: 
                /* Detailed ice scales */
                8px 8px 0 0 #AAFFFF,
                12px 10px 0 0 #88EEFF,
                18px 12px 0 0 #AAFFFF,
                22px 14px 0 0 #88EEFF,
                28px 16px 0 0 #AAFFFF,
                32px 18px 0 0 #88EEFF,
                38px 20px 0 0 #AAFFFF,
                10px 18px 0 0 #88EEFF,
                16px 20px 0 0 #AAFFFF,
                24px 22px 0 0 #88EEFF,
                30px 24px 0 0 #AAFFFF,
                36px 26px 0 0 #88EEFF,
                12px 28px 0 0 #AAFFFF,
                20px 30px 0 0 #88EEFF,
                28px 32px 0 0 #AAFFFF,
                34px 34px 0 0 #88EEFF,
                /* Ice spine */
                20px 5px 0 0 #66CCFF,
                22px 8px 0 0 #AAFFFF,
                24px 12px 0 0 #66CCFF,
                26px 16px 0 0 #AAFFFF,
                28px 20px 0 0 #66CCFF,
                30px 24px 0 0 #AAFFFF,
                32px 28px 0 0 #66CCFF,
                /* Front legs with claws */
                3px 58px 0 0 #88EEFF,
                3px 62px 0 0 #88EEFF,
                3px 66px 0 0 #66CCFF,
                7px 58px 0 0 #88EEFF,
                7px 62px 0 0 #88EEFF,
                7px 66px 0 0 #66CCFF,
                11px 58px 0 0 #88EEFF,
                11px 62px 0 0 #88EEFF,
                /* Back legs */
                33px 58px 0 0 #88EEFF,
                33px 62px 0 0 #88EEFF,
                33px 66px 0 0 #66CCFF,
                37px 58px 0 0 #88EEFF,
                37px 62px 0 0 #88EEFF,
                37px 66px 0 0 #66CCFF,
                41px 58px 0 0 #88EEFF,
                41px 62px 0 0 #88EEFF,
                /* Detailed tail */
                45px 48px 0 0 #88EEFF,
                48px 52px 0 0 #66CCFF,
                51px 56px 0 0 #88EEFF,
                54px 60px 0 0 #66CCFF,
                57px 64px 0 0 #88EEFF,
                60px 68px 0 0 #66CCFF,
                63px 72px 0 0 #88EEFF,
                66px 76px 0 0 #AAFFFF,
                69px 80px 0 0 #66CCFF,
                0 0 10px rgba(102, 204, 255, 0.5);
        }

        .pixel-dragon.frostbite::before {
            content: '';
            position: absolute;
            top: -30px;
            left: 6px;
            width: 38px;
            height: 35px;
            background: #AAFFFF;
            border: 2px solid #66CCFF;
            clip-path: polygon(12% 0%, 88% 0%, 100% 25%, 98% 50%, 85% 75%, 75% 100%, 25% 100%, 15% 75%, 2% 50%, 0% 25%);
            box-shadow: 
                10px 10px 0 0 #66CCFF,
                10px 10px 0 2px #88EEFF,
                12px 12px 0 0 #FFFFFF,
                22px 10px 0 0 #66CCFF,
                22px 10px 0 2px #88EEFF,
                24px 12px 0 0 #FFFFFF,
                12px 18px 0 0 #66CCFF,
                26px 18px 0 0 #66CCFF,
                14px 22px 0 0 #66CCFF,
                16px 24px 0 0 #AAFFFF,
                18px 24px 0 0 #88EEFF,
                20px 24px 0 0 #AAFFFF,
                22px 24px 0 0 #88EEFF,
                24px 24px 0 0 #AAFFFF,
                26px 22px 0 0 #66CCFF,
                4px -6px 0 0 #66CCFF,
                4px -6px 0 2px #AAFFFF,
                6px -10px 0 0 #AAFFFF,
                32px -6px 0 0 #66CCFF,
                32px -6px 0 2px #AAFFFF,
                34px -10px 0 0 #AAFFFF,
                8px 6px 0 0 #AAFFFF,
                30px 6px 0 0 #88EEFF;
            z-index: 1;
            display: block;
        }

        .pixel-dragon.frostbite::after {
            content: '';
            position: absolute;
            top: 12px;
            left: -28px;
            width: 28px;
            height: 45px;
            background: #AAFFFF;
            border: 2px solid #66CCFF;
            clip-path: polygon(0% 0%, 100% 3%, 98% 25%, 100% 50%, 95% 75%, 85% 95%, 0% 100%, 3% 50%);
            box-shadow: 
                78px 0 0 0 #AAFFFF,
                78px 0 0 2px #66CCFF,
                4px 12px 0 0 #88EEFF,
                4px 12px 0 1px #66CCFF,
                8px 18px 0 0 #66CCFF,
                8px 18px 0 1px #AAFFFF,
                12px 24px 0 0 #88EEFF,
                12px 24px 0 1px #66CCFF,
                16px 30px 0 0 #66CCFF,
                16px 30px 0 1px #AAFFFF,
                20px 36px 0 0 #88EEFF,
                20px 36px 0 1px #66CCFF,
                82px 12px 0 0 #88EEFF,
                82px 12px 0 1px #66CCFF,
                86px 18px 0 0 #66CCFF,
                86px 18px 0 1px #AAFFFF,
                90px 24px 0 0 #88EEFF,
                90px 24px 0 1px #66CCFF,
                94px 30px 0 0 #66CCFF,
                94px 30px 0 1px #AAFFFF,
                98px 36px 0 0 #88EEFF,
                98px 36px 0 1px #66CCFF,
                -2px 40px 0 0 #66CCFF,
                -2px 40px 0 1px #AAFFFF,
                0px 42px 0 0 #AAFFFF,
                2px 44px 0 0 #66CCFF,
                106px 40px 0 0 #66CCFF,
                106px 40px 0 1px #AAFFFF,
                108px 42px 0 0 #AAFFFF,
                110px 44px 0 0 #66CCFF;
            z-index: 0;
            display: block;
        }

        .pixel-dragon.radiant {
            background: #FFD700 !important;
            width: 50px;
            height: 70px;
            border: 2px solid #FFAA00;
            position: relative;
            overflow: visible;
            animation: lightPulse 1.5s infinite;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: 
                /* Detailed light scales */
                8px 8px 0 0 #FFFF88,
                12px 10px 0 0 #FFD700,
                18px 12px 0 0 #FFFF88,
                22px 14px 0 0 #FFD700,
                28px 16px 0 0 #FFFF88,
                32px 18px 0 0 #FFD700,
                38px 20px 0 0 #FFFF88,
                10px 18px 0 0 #FFD700,
                16px 20px 0 0 #FFFF88,
                24px 22px 0 0 #FFD700,
                30px 24px 0 0 #FFFF88,
                36px 26px 0 0 #FFD700,
                12px 28px 0 0 #FFFF88,
                20px 30px 0 0 #FFD700,
                28px 32px 0 0 #FFFF88,
                34px 34px 0 0 #FFD700,
                /* Light spine */
                20px 5px 0 0 #FFAA00,
                22px 8px 0 0 #FFFF88,
                24px 12px 0 0 #FFAA00,
                26px 16px 0 0 #FFFF88,
                28px 20px 0 0 #FFAA00,
                30px 24px 0 0 #FFFF88,
                32px 28px 0 0 #FFAA00,
                /* Front legs with claws */
                3px 58px 0 0 #FFD700,
                3px 62px 0 0 #FFD700,
                3px 66px 0 0 #FFAA00,
                7px 58px 0 0 #FFD700,
                7px 62px 0 0 #FFD700,
                7px 66px 0 0 #FFAA00,
                11px 58px 0 0 #FFD700,
                11px 62px 0 0 #FFD700,
                /* Back legs */
                33px 58px 0 0 #FFD700,
                33px 62px 0 0 #FFD700,
                33px 66px 0 0 #FFAA00,
                37px 58px 0 0 #FFD700,
                37px 62px 0 0 #FFD700,
                37px 66px 0 0 #FFAA00,
                41px 58px 0 0 #FFD700,
                41px 62px 0 0 #FFD700,
                /* Detailed tail */
                45px 48px 0 0 #FFD700,
                48px 52px 0 0 #FFAA00,
                51px 56px 0 0 #FFD700,
                54px 60px 0 0 #FFAA00,
                57px 64px 0 0 #FFD700,
                60px 68px 0 0 #FFAA00,
                63px 72px 0 0 #FFD700,
                66px 76px 0 0 #FFFF88,
                69px 80px 0 0 #FFAA00,
                0 0 10px rgba(255, 215, 0, 0.5);
        }

        .pixel-dragon.radiant::before {
            content: '';
            position: absolute;
            top: -30px;
            left: 6px;
            width: 38px;
            height: 35px;
            background: #FFFF88;
            border: 2px solid #FFD700;
            clip-path: polygon(12% 0%, 88% 0%, 100% 25%, 98% 50%, 85% 75%, 75% 100%, 25% 100%, 15% 75%, 2% 50%, 0% 25%);
            box-shadow: 
                10px 10px 0 0 #FFD700,
                10px 10px 0 2px #FFAA00,
                12px 12px 0 0 #FFFFFF,
                22px 10px 0 0 #FFD700,
                22px 10px 0 2px #FFAA00,
                24px 12px 0 0 #FFFFFF,
                12px 18px 0 0 #FFD700,
                26px 18px 0 0 #FFD700,
                14px 22px 0 0 #FFD700,
                16px 24px 0 0 #FFFF88,
                18px 24px 0 0 #FFD700,
                20px 24px 0 0 #FFFF88,
                22px 24px 0 0 #FFD700,
                24px 24px 0 0 #FFFF88,
                26px 22px 0 0 #FFD700,
                4px -6px 0 0 #FFD700,
                4px -6px 0 2px #FFFF88,
                6px -10px 0 0 #FFFF88,
                32px -6px 0 0 #FFD700,
                32px -6px 0 2px #FFFF88,
                34px -10px 0 0 #FFFF88,
                8px 6px 0 0 #FFFF88,
                30px 6px 0 0 #FFD700;
            z-index: 1;
            display: block;
        }

        .pixel-dragon.radiant::after {
            content: '';
            position: absolute;
            top: 12px;
            left: -28px;
            width: 28px;
            height: 45px;
            background: #FFFF88;
            border: 2px solid #FFD700;
            clip-path: polygon(0% 0%, 100% 3%, 98% 25%, 100% 50%, 95% 75%, 85% 95%, 0% 100%, 3% 50%);
            box-shadow: 
                78px 0 0 0 #FFFF88,
                78px 0 0 2px #FFD700,
                4px 12px 0 0 #FFD700,
                4px 12px 0 1px #FFAA00,
                8px 18px 0 0 #FFAA00,
                8px 18px 0 1px #FFFF88,
                12px 24px 0 0 #FFD700,
                12px 24px 0 1px #FFAA00,
                16px 30px 0 0 #FFAA00,
                16px 30px 0 1px #FFFF88,
                20px 36px 0 0 #FFD700,
                20px 36px 0 1px #FFAA00,
                82px 12px 0 0 #FFD700,
                82px 12px 0 1px #FFAA00,
                86px 18px 0 0 #FFAA00,
                86px 18px 0 1px #FFFF88,
                90px 24px 0 0 #FFD700,
                90px 24px 0 1px #FFAA00,
                94px 30px 0 0 #FFAA00,
                94px 30px 0 1px #FFFF88,
                98px 36px 0 0 #FFD700,
                98px 36px 0 1px #FFAA00,
                -2px 40px 0 0 #FFAA00,
                -2px 40px 0 1px #FFFF88,
                0px 42px 0 0 #FFFF88,
                2px 44px 0 0 #FFAA00,
                106px 40px 0 0 #FFAA00,
                106px 40px 0 1px #FFFF88,
                108px 42px 0 0 #FFFF88,
                110px 44px 0 0 #FFAA00;
            z-index: 0;
            display: block;
        }

        @keyframes lightPulse {
            0%, 100% { box-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 60px rgba(255, 255, 136, 0.8); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 136, 1), 0 0 80px rgba(255, 215, 0, 1); }
        }

        .pixel-dragon.stormwing {
            background: #FFDD00 !important;
            width: 50px;
            height: 70px;
            border: 2px solid #FFFF44;
            position: relative;
            overflow: visible;
            animation: lightningFlicker 0.3s infinite;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: 
                /* Detailed lightning scales */
                8px 8px 0 0 #FFFF44,
                12px 10px 0 0 #FFDD00,
                18px 12px 0 0 #FFFF44,
                22px 14px 0 0 #FFDD00,
                28px 16px 0 0 #FFFF44,
                32px 18px 0 0 #FFDD00,
                38px 20px 0 0 #FFFF44,
                10px 18px 0 0 #FFDD00,
                16px 20px 0 0 #FFFF44,
                24px 22px 0 0 #FFDD00,
                30px 24px 0 0 #FFFF44,
                36px 26px 0 0 #FFDD00,
                12px 28px 0 0 #FFFF44,
                20px 30px 0 0 #FFDD00,
                28px 32px 0 0 #FFFF44,
                34px 34px 0 0 #FFDD00,
                /* Lightning spine */
                20px 5px 0 0 #FFFF44,
                22px 8px 0 0 #FFDD00,
                24px 12px 0 0 #FFFF44,
                26px 16px 0 0 #FFDD00,
                28px 20px 0 0 #FFFF44,
                30px 24px 0 0 #FFDD00,
                32px 28px 0 0 #FFFF44,
                /* Front legs with claws */
                3px 58px 0 0 #FFDD00,
                3px 62px 0 0 #FFDD00,
                3px 66px 0 0 #FFFF44,
                7px 58px 0 0 #FFDD00,
                7px 62px 0 0 #FFDD00,
                7px 66px 0 0 #FFFF44,
                11px 58px 0 0 #FFDD00,
                11px 62px 0 0 #FFDD00,
                /* Back legs */
                33px 58px 0 0 #FFDD00,
                33px 62px 0 0 #FFDD00,
                33px 66px 0 0 #FFFF44,
                37px 58px 0 0 #FFDD00,
                37px 62px 0 0 #FFDD00,
                37px 66px 0 0 #FFFF44,
                41px 58px 0 0 #FFDD00,
                41px 62px 0 0 #FFDD00,
                /* Detailed tail */
                45px 48px 0 0 #FFDD00,
                48px 52px 0 0 #FFFF44,
                51px 56px 0 0 #FFDD00,
                54px 60px 0 0 #FFFF44,
                57px 64px 0 0 #FFDD00,
                60px 68px 0 0 #FFFF44,
                63px 72px 0 0 #FFDD00,
                66px 76px 0 0 #FFFF44,
                69px 80px 0 0 #FFDD00,
                0 0 10px rgba(255, 221, 0, 0.5);
        }

        .pixel-dragon.stormwing::before {
            content: '';
            position: absolute;
            top: -30px;
            left: 6px;
            width: 38px;
            height: 35px;
            background: #FFFF44;
            border: 2px solid #FFDD00;
            clip-path: polygon(12% 0%, 88% 0%, 100% 25%, 98% 50%, 85% 75%, 75% 100%, 25% 100%, 15% 75%, 2% 50%, 0% 25%);
            box-shadow: 
                10px 10px 0 0 #FFDD00,
                10px 10px 0 2px #FFFF44,
                12px 12px 0 0 #FFFFFF,
                22px 10px 0 0 #FFDD00,
                22px 10px 0 2px #FFFF44,
                24px 12px 0 0 #FFFFFF,
                12px 18px 0 0 #FFDD00,
                26px 18px 0 0 #FFDD00,
                14px 22px 0 0 #FFDD00,
                16px 24px 0 0 #FFFF44,
                18px 24px 0 0 #FFDD00,
                20px 24px 0 0 #FFFF44,
                22px 24px 0 0 #FFDD00,
                24px 24px 0 0 #FFFF44,
                26px 22px 0 0 #FFDD00,
                4px -6px 0 0 #FFDD00,
                4px -6px 0 2px #FFFF44,
                6px -10px 0 0 #FFFF44,
                32px -6px 0 0 #FFDD00,
                32px -6px 0 2px #FFFF44,
                34px -10px 0 0 #FFFF44,
                8px 6px 0 0 #FFFF44,
                30px 6px 0 0 #FFDD00;
            z-index: 1;
            display: block;
        }

        .pixel-dragon.stormwing::after {
            content: '';
            position: absolute;
            top: 12px;
            left: -28px;
            width: 28px;
            height: 45px;
            background: #FFFF44;
            border: 2px solid #FFDD00;
            clip-path: polygon(0% 0%, 100% 3%, 98% 25%, 100% 50%, 95% 75%, 85% 95%, 0% 100%, 3% 50%);
            box-shadow: 
                78px 0 0 0 #FFFF44,
                78px 0 0 2px #FFDD00,
                4px 12px 0 0 #FFDD00,
                4px 12px 0 1px #FFFF44,
                8px 18px 0 0 #FFFF44,
                8px 18px 0 1px #FFDD00,
                12px 24px 0 0 #FFDD00,
                12px 24px 0 1px #FFFF44,
                16px 30px 0 0 #FFFF44,
                16px 30px 0 1px #FFDD00,
                20px 36px 0 0 #FFDD00,
                20px 36px 0 1px #FFFF44,
                82px 12px 0 0 #FFDD00,
                82px 12px 0 1px #FFFF44,
                86px 18px 0 0 #FFFF44,
                86px 18px 0 1px #FFDD00,
                90px 24px 0 0 #FFDD00,
                90px 24px 0 1px #FFFF44,
                94px 30px 0 0 #FFFF44,
                94px 30px 0 1px #FFDD00,
                98px 36px 0 0 #FFDD00,
                98px 36px 0 1px #FFFF44,
                -2px 40px 0 0 #FFFF44,
                -2px 40px 0 1px #FFDD00,
                0px 42px 0 0 #FFDD00,
                2px 44px 0 0 #FFFF44,
                106px 40px 0 0 #FFFF44,
                106px 40px 0 1px #FFDD00,
                108px 42px 0 0 #FFDD00,
                110px 44px 0 0 #FFFF44;
            z-index: 0;
            display: block;
        }

        @keyframes lightningFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .pixel-dragon.metalbeak {
            background: #AAAAAA !important;
            width: 50px;
            height: 70px;
            border: 2px solid #888888;
            position: relative;
            overflow: visible;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: 
                /* Detailed metal scales */
                8px 8px 0 0 #CCCCCC,
                12px 10px 0 0 #AAAAAA,
                18px 12px 0 0 #CCCCCC,
                22px 14px 0 0 #AAAAAA,
                28px 16px 0 0 #CCCCCC,
                32px 18px 0 0 #AAAAAA,
                38px 20px 0 0 #CCCCCC,
                10px 18px 0 0 #AAAAAA,
                16px 20px 0 0 #CCCCCC,
                24px 22px 0 0 #AAAAAA,
                30px 24px 0 0 #CCCCCC,
                36px 26px 0 0 #AAAAAA,
                12px 28px 0 0 #CCCCCC,
                20px 30px 0 0 #AAAAAA,
                28px 32px 0 0 #CCCCCC,
                34px 34px 0 0 #AAAAAA,
                /* Metal spine */
                20px 5px 0 0 #888888,
                22px 8px 0 0 #CCCCCC,
                24px 12px 0 0 #888888,
                26px 16px 0 0 #CCCCCC,
                28px 20px 0 0 #888888,
                30px 24px 0 0 #CCCCCC,
                32px 28px 0 0 #888888,
                /* Front legs with claws */
                3px 58px 0 0 #AAAAAA,
                3px 62px 0 0 #AAAAAA,
                3px 66px 0 0 #888888,
                7px 58px 0 0 #AAAAAA,
                7px 62px 0 0 #AAAAAA,
                7px 66px 0 0 #888888,
                11px 58px 0 0 #AAAAAA,
                11px 62px 0 0 #AAAAAA,
                /* Back legs */
                33px 58px 0 0 #AAAAAA,
                33px 62px 0 0 #AAAAAA,
                33px 66px 0 0 #888888,
                37px 58px 0 0 #AAAAAA,
                37px 62px 0 0 #AAAAAA,
                37px 66px 0 0 #888888,
                41px 58px 0 0 #AAAAAA,
                41px 62px 0 0 #AAAAAA,
                /* Detailed tail */
                45px 48px 0 0 #AAAAAA,
                48px 52px 0 0 #888888,
                51px 56px 0 0 #AAAAAA,
                54px 60px 0 0 #888888,
                57px 64px 0 0 #AAAAAA,
                60px 68px 0 0 #888888,
                63px 72px 0 0 #AAAAAA,
                66px 76px 0 0 #CCCCCC,
                69px 80px 0 0 #888888,
                0 0 10px rgba(136, 136, 136, 0.5);
        }

        .pixel-dragon.metalbeak::before {
            content: '';
            position: absolute;
            top: -25px;
            left: 8px;
            width: 35px;
            height: 30px;
            background: #CCCCCC;
            border: 2px solid #888888;
            clip-path: polygon(15% 0%, 85% 0%, 100% 30%, 95% 60%, 80% 100%, 20% 100%, 5% 60%, 0% 30%);
            box-shadow: 
                10px 12px 0 0 #888888,
                22px 12px 0 0 #888888,
                15px 20px 0 0 #AAAAAA,
                20px 20px 0 0 #AAAAAA,
                5px -5px 0 0 #888888,
                30px -5px 0 0 #888888,
                8px -8px 0 0 #CCCCCC,
                27px -8px 0 0 #CCCCCC;
            z-index: 1;
            display: block;
        }

        .pixel-dragon.metalbeak::after {
            content: '';
            position: absolute;
            top: 15px;
            left: -25px;
            width: 25px;
            height: 40px;
            background: #CCCCCC;
            border: 2px solid #888888;
            clip-path: polygon(0% 0%, 100% 5%, 95% 30%, 100% 60%, 90% 95%, 0% 100%, 5% 50%);
            box-shadow: 
                75px 0 0 0 #CCCCCC,
                75px 0 0 2px #888888,
                5px 15px 0 0 #AAAAAA,
                20px 20px 0 0 #AAAAAA,
                80px 15px 0 0 #AAAAAA,
                95px 20px 0 0 #AAAAAA,
                0px 35px 0 0 #888888,
                100px 35px 0 0 #888888,
                8px 25px 0 0 #CCCCCC,
                18px 25px 0 0 #CCCCCC;
            z-index: 0;
            display: block;
        }

        .pixel-dragon.vineclaw {
            background: #44AA44 !important;
            width: 50px;
            height: 70px;
            border: 2px solid #228822;
            position: relative;
            overflow: visible;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: 
                10px 10px 0 0 #66DD66,
                20px 15px 0 0 #44AA44,
                30px 20px 0 0 #66DD66,
                15px 25px 0 0 #44AA44,
                25px 30px 0 0 #66DD66,
                35px 35px 0 0 #44AA44,
                5px 60px 0 0 #44AA44,
                5px 65px 0 0 #44AA44,
                10px 60px 0 0 #44AA44,
                10px 65px 0 0 #44AA44,
                35px 60px 0 0 #44AA44,
                35px 65px 0 0 #44AA44,
                40px 60px 0 0 #44AA44,
                40px 65px 0 0 #44AA44,
                45px 50px 0 0 #44AA44,
                50px 55px 0 0 #228822,
                55px 60px 0 0 #44AA44,
                60px 65px 0 0 #228822,
                65px 70px 0 0 #44AA44,
                70px 75px 0 0 #66DD66,
                0 0 10px rgba(34, 136, 34, 0.5);
        }

        .pixel-dragon.vineclaw::before {
            content: '';
            position: absolute;
            top: -25px;
            left: 8px;
            width: 35px;
            height: 30px;
            background: #66DD66;
            border: 2px solid #228822;
            clip-path: polygon(15% 0%, 85% 0%, 100% 30%, 95% 60%, 80% 100%, 20% 100%, 5% 60%, 0% 30%);
            box-shadow: 
                10px 12px 0 0 #228822,
                22px 12px 0 0 #228822,
                15px 20px 0 0 #44AA44,
                20px 20px 0 0 #44AA44,
                5px -5px 0 0 #228822,
                30px -5px 0 0 #228822,
                8px -8px 0 0 #66DD66,
                27px -8px 0 0 #66DD66;
            z-index: 1;
            display: block;
        }

        .pixel-dragon.vineclaw::after {
            content: '';
            position: absolute;
            top: 15px;
            left: -25px;
            width: 25px;
            height: 40px;
            background: #66DD66;
            border: 2px solid #228822;
            clip-path: polygon(0% 0%, 100% 5%, 95% 30%, 100% 60%, 90% 95%, 0% 100%, 5% 50%);
            box-shadow: 
                75px 0 0 0 #66DD66,
                75px 0 0 2px #228822,
                5px 15px 0 0 #44AA44,
                20px 20px 0 0 #44AA44,
                80px 15px 0 0 #44AA44,
                95px 20px 0 0 #44AA44,
                0px 35px 0 0 #228822,
                100px 35px 0 0 #228822;
            z-index: 0;
            display: block;
        }

        .pixel-dragon.shadowmaw {
            background: #000000 !important;
            width: 50px;
            height: 70px;
            border: 2px solid #8844AA;
            position: relative;
            overflow: visible;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: 
                /* Detailed shadow scales */
                8px 8px 0 0 #8844AA,
                12px 10px 0 0 #000000,
                18px 12px 0 0 #8844AA,
                22px 14px 0 0 #000000,
                28px 16px 0 0 #8844AA,
                32px 18px 0 0 #000000,
                38px 20px 0 0 #8844AA,
                10px 18px 0 0 #000000,
                16px 20px 0 0 #8844AA,
                24px 22px 0 0 #000000,
                30px 24px 0 0 #8844AA,
                36px 26px 0 0 #000000,
                12px 28px 0 0 #8844AA,
                20px 30px 0 0 #000000,
                28px 32px 0 0 #8844AA,
                34px 34px 0 0 #000000,
                /* Shadow spine */
                20px 5px 0 0 #BB88DD,
                22px 8px 0 0 #8844AA,
                24px 12px 0 0 #BB88DD,
                26px 16px 0 0 #8844AA,
                28px 20px 0 0 #BB88DD,
                30px 24px 0 0 #8844AA,
                32px 28px 0 0 #BB88DD,
                /* Front legs with claws */
                3px 58px 0 0 #000000,
                3px 62px 0 0 #000000,
                3px 66px 0 0 #8844AA,
                7px 58px 0 0 #000000,
                7px 62px 0 0 #000000,
                7px 66px 0 0 #8844AA,
                11px 58px 0 0 #000000,
                11px 62px 0 0 #000000,
                /* Back legs */
                33px 58px 0 0 #000000,
                33px 62px 0 0 #000000,
                33px 66px 0 0 #8844AA,
                37px 58px 0 0 #000000,
                37px 62px 0 0 #000000,
                37px 66px 0 0 #8844AA,
                41px 58px 0 0 #000000,
                41px 62px 0 0 #000000,
                /* Detailed tail */
                45px 48px 0 0 #000000,
                48px 52px 0 0 #8844AA,
                51px 56px 0 0 #000000,
                54px 60px 0 0 #8844AA,
                57px 64px 0 0 #000000,
                60px 68px 0 0 #8844AA,
                63px 72px 0 0 #000000,
                66px 76px 0 0 #BB88DD,
                69px 80px 0 0 #8844AA,
                0 0 10px rgba(136, 68, 170, 0.5);
        }

        .pixel-dragon.shadowmaw::before {
            content: '';
            position: absolute;
            top: -30px;
            left: 6px;
            width: 38px;
            height: 35px;
            background: #8844AA;
            border: 2px solid #BB88DD;
            clip-path: polygon(12% 0%, 88% 0%, 100% 25%, 98% 50%, 85% 75%, 75% 100%, 25% 100%, 15% 75%, 2% 50%, 0% 25%);
            box-shadow: 
                10px 10px 0 0 #BB88DD,
                10px 10px 0 2px #000000,
                12px 12px 0 0 #FFFFFF,
                22px 10px 0 0 #BB88DD,
                22px 10px 0 2px #000000,
                24px 12px 0 0 #FFFFFF,
                12px 18px 0 0 #BB88DD,
                26px 18px 0 0 #BB88DD,
                14px 22px 0 0 #BB88DD,
                16px 24px 0 0 #8844AA,
                18px 24px 0 0 #000000,
                20px 24px 0 0 #8844AA,
                22px 24px 0 0 #000000,
                24px 24px 0 0 #8844AA,
                26px 22px 0 0 #BB88DD,
                4px -6px 0 0 #BB88DD,
                4px -6px 0 2px #8844AA,
                6px -10px 0 0 #8844AA,
                32px -6px 0 0 #BB88DD,
                32px -6px 0 2px #8844AA,
                34px -10px 0 0 #8844AA,
                8px 6px 0 0 #8844AA,
                30px 6px 0 0 #000000;
            z-index: 1;
            display: block;
        }

        .pixel-dragon.shadowmaw::after {
            content: '';
            position: absolute;
            top: 12px;
            left: -28px;
            width: 28px;
            height: 45px;
            background: #8844AA;
            border: 2px solid #BB88DD;
            clip-path: polygon(0% 0%, 100% 3%, 98% 25%, 100% 50%, 95% 75%, 85% 95%, 0% 100%, 3% 50%);
            box-shadow: 
                78px 0 0 0 #8844AA,
                78px 0 0 2px #BB88DD,
                4px 12px 0 0 #000000,
                4px 12px 0 1px #BB88DD,
                8px 18px 0 0 #BB88DD,
                8px 18px 0 1px #8844AA,
                12px 24px 0 0 #000000,
                12px 24px 0 1px #BB88DD,
                16px 30px 0 0 #BB88DD,
                16px 30px 0 1px #8844AA,
                20px 36px 0 0 #000000,
                20px 36px 0 1px #BB88DD,
                82px 12px 0 0 #000000,
                82px 12px 0 1px #BB88DD,
                86px 18px 0 0 #BB88DD,
                86px 18px 0 1px #8844AA,
                90px 24px 0 0 #000000,
                90px 24px 0 1px #BB88DD,
                94px 30px 0 0 #BB88DD,
                94px 30px 0 1px #8844AA,
                98px 36px 0 0 #000000,
                98px 36px 0 1px #BB88DD,
                -2px 40px 0 0 #BB88DD,
                -2px 40px 0 1px #8844AA,
                0px 42px 0 0 #8844AA,
                2px 44px 0 0 #BB88DD,
                106px 40px 0 0 #BB88DD,
                106px 40px 0 1px #8844AA,
                108px 42px 0 0 #8844AA,
                110px 44px 0 0 #BB88DD;
            z-index: 0;
            display: block;
        }

        .pixel-dragon.aquaris {
            background: #4488FF !important;
            width: 50px;
            height: 70px;
            border: 2px solid #2266FF;
            position: relative;
            overflow: visible;
            animation: waterFlow 2s infinite;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            box-shadow: 
                10px 10px 0 0 #66AAFF,
                20px 15px 0 0 #4488FF,
                30px 20px 0 0 #66AAFF,
                15px 25px 0 0 #4488FF,
                25px 30px 0 0 #66AAFF,
                35px 35px 0 0 #4488FF,
                5px 60px 0 0 #4488FF,
                5px 65px 0 0 #4488FF,
                10px 60px 0 0 #4488FF,
                10px 65px 0 0 #4488FF,
                35px 60px 0 0 #4488FF,
                35px 65px 0 0 #4488FF,
                40px 60px 0 0 #4488FF,
                40px 65px 0 0 #4488FF,
                45px 50px 0 0 #4488FF,
                50px 55px 0 0 #2266FF,
                55px 60px 0 0 #4488FF,
                60px 65px 0 0 #2266FF,
                65px 70px 0 0 #4488FF,
                70px 75px 0 0 #66AAFF,
                0 0 10px rgba(34, 102, 255, 0.5);
        }

        .pixel-dragon.aquaris::before {
            content: '';
            position: absolute;
            top: -25px;
            left: 8px;
            width: 35px;
            height: 30px;
            background: #66AAFF;
            border: 2px solid #2266FF;
            clip-path: polygon(15% 0%, 85% 0%, 100% 30%, 95% 60%, 80% 100%, 20% 100%, 5% 60%, 0% 30%);
            box-shadow: 
                10px 12px 0 0 #2266FF,
                22px 12px 0 0 #2266FF,
                15px 20px 0 0 #4488FF,
                20px 20px 0 0 #4488FF,
                5px -5px 0 0 #2266FF,
                30px -5px 0 0 #2266FF,
                8px -8px 0 0 #66AAFF,
                27px -8px 0 0 #66AAFF;
            z-index: 1;
            display: block;
        }

        .pixel-dragon.aquaris::after {
            content: '';
            position: absolute;
            top: 15px;
            left: -25px;
            width: 25px;
            height: 40px;
            background: #66AAFF;
            border: 2px solid #2266FF;
            clip-path: polygon(0% 0%, 100% 5%, 95% 30%, 100% 60%, 90% 95%, 0% 100%, 5% 50%);
            box-shadow: 
                75px 0 0 0 #66AAFF,
                75px 0 0 2px #2266FF,
                5px 15px 0 0 #4488FF,
                20px 20px 0 0 #4488FF,
                80px 15px 0 0 #4488FF,
                95px 20px 0 0 #4488FF,
                0px 35px 0 0 #2266FF,
                100px 35px 0 0 #2266FF;
            z-index: 0;
            display: block;
        }

        @keyframes waterFlow {
            0%, 100% { background-position: 0 0; }
            50% { background-position: 0 20px; }
        }

        .adventure-header {
            text-align: center;
            margin-bottom: 15px;
        }

        .adventure-header h1 {
            color: #FFD700;
            font-size: 28px;
            margin: 5px 0;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .adventure-actions {
            text-align: center;
            margin-top: 20px;
        }

        .back-to-select-button {
            background-color: #66AAFF;
            color: #FFFFFF;
            font-size: 16px;
            font-weight: bold;
            padding: 10px 25px;
            border: 3px solid #88CCFF;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(102, 170, 255, 0.4);
            margin: 0 10px;
            text-decoration: none;
            display: inline-block;
        }

        .back-to-select-button:hover {
            background-color: #4488FF;
            box-shadow: 0 6px 12px rgba(102, 170, 255, 0.6);
            transform: translateY(-2px);
        }

        /* Room Map Styles */
        .room-map-container {
            max-width: 1200px;
            margin: 15px auto;
            padding: 15px;
            background: linear-gradient(180deg, #1a1a2e 0%, #2a2a3e 100%);
            border: 3px solid #5a5a7a;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .room-map-title {
            text-align: center;
            color: #FFD700;
            font-size: 18px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .room-map-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            justify-items: center;
            align-items: center;
            padding: 10px;
        }

        .room-map-cell {
            width: 40px;
            height: 40px;
            border: 2px solid #5a5a7a;
            border-radius: 5px;
            background-color: #2a2a3e;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #888;
            transition: all 0.2s;
            cursor: default;
        }

        .room-map-cell.visited {
            background-color: #3a4a5e;
            border-color: #6a7a8a;
        }

        .room-map-cell.current {
            background-color: #FFD700;
            border-color: #FFAA00;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            color: #000;
            font-weight: bold;
            transform: scale(1.1);
        }

        .room-map-cell.unreachable {
            background-color: #1a1a1a;
            border-color: #3a3a3a;
            opacity: 0.3;
        }

        @media screen and (max-width: 768px) {
            .room-map-container {
                padding: 10px;
                margin: 10px auto;
            }

            .room-map-title {
                font-size: 14px;
                margin-bottom: 8px;
            }

            .room-map-grid {
                gap: 3px;
                padding: 5px;
            }

            .room-map-cell {
                width: 30px;
                height: 30px;
                font-size: 8px;
            }
        }

        /* Virtual Joystick for Mobile */
        .joystick-container {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 140px;
            height: 140px;
            display: none;
            z-index: 1000;
            touch-action: none;
        }

        .joystick-base {
            width: 140px;
            height: 140px;
            background: rgba(136, 68, 170, 0.6);
            border: 4px solid rgba(187, 136, 221, 0.8);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .joystick-stick {
            width: 70px;
            height: 70px;
            background: rgba(255, 215, 0, 0.9);
            border: 3px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            transition: transform 0.1s ease-out;
            pointer-events: none;
        }

        .joystick-container.active .joystick-stick {
            transition: none;
        }

        /* Show joystick only on mobile */
        @media screen and (max-width: 768px) {
            .joystick-container {
                display: block;
            }
        }

        /* Mobile Responsive Styles */
        @media screen and (max-width: 768px) {
            .story-container {
                padding: 2px;
                margin: 2px auto;
            }

            .story-header {
                margin-bottom: 4px;
            }

            .story-header h1 {
                font-size: 20px;
                margin: 2px 0;
            }

            .story-header p {
                font-size: 14px;
                margin: 1px 0;
            }

            .story-arena {
                flex-direction: column;
                gap: 4px;
                margin-bottom: 4px;
            }

            .story-side {
                min-width: 100%;
            }

            .story-side h2 {
                font-size: 16px;
                margin-bottom: 3px;
            }

            .dragon-selector {
                font-size: 14px;
                padding: 4px;
                margin-bottom: 3px;
            }

            .selected-dragon {
                padding: 3px;
                margin-top: 3px;
            }

            .selected-dragon img {
                max-width: 100px;
                margin: 3px auto;
            }

            .selected-dragon h3 {
                font-size: 14px;
                margin: 3px 0 2px 0;
            }

            .selected-dragon .element {
                font-size: 12px;
                margin: 2px 0;
            }

            .selected-dragon h4 {
                font-size: 13px;
                margin-top: 4px;
                margin-bottom: 2px;
            }

            .selected-dragon ol {
                font-size: 11px;
                line-height: 1.3;
                padding-left: 15px;
                margin: 2px 0;
            }

            .selected-dragon ol li {
                margin-bottom: 1px;
            }

            .story-button-container {
                margin: 4px 0;
            }

            .story-start-button {
                font-size: 14px;
                padding: 5px 12px;
                width: 100%;
                max-width: 200px;
            }

            .back-link-container {
                margin-top: 4px;
            }

            .back-link {
                font-size: 12px;
                padding: 4px 10px;
                display: block;
                margin: 2px auto;
                width: fit-content;
            }

            .cave-container {
                padding: 10px;
                margin: 10px auto;
            }

            .cave-background {
                height: 300px;
            }

            .pixel-dragon {
                width: 50px;
                height: 50px;
            }

            .adventure-header h1 {
                font-size: 20px;
            }

            .adventure-header p {
                font-size: 14px;
            }

            .back-to-select-button {
                font-size: 14px;
                padding: 8px 15px;
                margin: 5px;
            }
        }
    </style>
</head>
<body>
    <!-- Main Content Section -->
    <main>
        <div class="story-container">
            <!-- Selection Area -->
            <div id="selection-area" class="selection-area">
                <div class="story-header">
                    <h1>ADVENTURE MODE</h1>
                    <p>Choose your dragon to begin the adventure!</p>
                </div>

                <div class="story-arena">
                    <!-- Dragon Selection -->
                    <div class="story-side">
                        <h2>Your Dragon</h2>
                        <select id="dragon-select" class="dragon-selector">
                            <option value="">-- Choose Your Dragon --</option>
                            <option value="breezeflight">Breezeflight the Windwhisper</option>
                            <option value="chaosflare">Chaosflare the Stormbringer</option>
                            <option value="crystalwing">Crystalwing the Prismkeeper</option>
                            <option value="earthheart">Earthheart the Stonekeeper</option>
                            <option value="flamethorn">Flamethorn the Firebringer</option>
                            <option value="frostbite">Frostbite the Iceweaver</option>
                            <option value="radiant">Radiant the Sunbeam</option>
                            <option value="stormwing">Stormwing the Skybreaker</option>
                            <option value="metalbeak">Metalbeak the Forgeguard</option>
                            <option value="vineclaw">Vineclaw the Lifegiver</option>
                            <option value="shadowmaw">Shadowmaw the Nightstalker</option>
                            <option value="aquaris">Aquaris the Depthcaller</option>
                        </select>
                        <div id="dragon-display"></div>
                    </div>
                </div>

                <div class="story-button-container">
                    <button id="story-start-button" class="story-start-button" disabled>Start Adventure</button>
                </div>

                <div class="back-link-container">
                    <a href="index.html" class="back-link"> Back to Dragon Lair</a>
                </div>
            </div>

            <!-- Adventure Game View (hidden initially) -->
            <div id="adventure-view" class="adventure-view">
                <div class="adventure-header">
                    <h1>YOUR ADVENTURE</h1>
                    <p id="adventure-dragon-name" style="color: #E0E0E0; font-size: 18px; margin: 10px 0;"></p>
                </div>

                <div class="cave-container">
                    <div class="cave-background">
                        <div class="cave-stalactites"></div>
                        <img id="pixel-dragon" class="pixel-dragon" src="images/icons/aquarius-icon.jpg" alt="Dragon" />
                        <button id="teleport-main-button" class="teleport-main-button"> Main Room</button>
                    </div>
                </div>

                <div class="room-map-container">
                    <div class="room-map-title">MAP</div>
                    <div id="room-map-grid" class="room-map-grid"></div>
                </div>

                <div class="adventure-actions">
                    <button id="back-to-select-button" class="back-to-select-button">Back to Selection</button>
                    <a href="index.html" class="back-link"> Back to Dragon Lair</a>
                </div>
            </div>
        </div>
    </main>

    <!-- Virtual Joystick for Mobile -->
    <div id="joystick-container" class="joystick-container">
        <div class="joystick-base">
            <div class="joystick-stick"></div>
        </div>
    </div>

    <script>
        // Dragon data with all information
        const dragonData = {
            breezeflight: {
                name: "Breezeflight the Windwhisper",
                element: "Air",
                image: "images/breezeflight.jpg",
                powers: [
                    { name: "Wind Messenger", description: "Breezeflight can create air currents that carry sounds and messages throughout the entire lair, making him the perfect messenger between dragons and across great distances." },
                    { name: "Gust Speed", description: "By riding and manipulating air currents, Breezeflight can achieve incredible speeds, becoming a silver-white blur that moves faster than any other dragon." },
                    { name: "Whisper Network", description: "He can hear and understand the language of the winds, allowing him to listen to conversations carried on air currents from miles away." },
                    { name: "Gentle Levitation", description: "Breezeflight can create powerful upward air currents that allow him to lift objects, creatures, or even other dragons without causing harm, using the gentlest of breezes." },
                    { name: "Pollination Wind", description: "By controlling precise air currents, he can spread seeds and pollen across vast distances, helping Vineclaw's gardens flourish throughout the entire lair." },
                    { name: "Refreshing Breeze (Healing)", description: "Breezeflight can channel pure, revitalizing air currents that flow through his body, healing wounds and restoring his strength with the gentle touch of the wind.", isHealing: true },
                    { name: "Air Barrier (Shield)", description: "Breezeflight can create a protective barrier of compressed air currents that deflects attacks and shields him from incoming damage.", isShield: true },
                    { name: "Hurricane Revival (Instant Heal)", description: "Breezeflight can summon a massive hurricane of pure life-giving air that instantly restores all of his health in a single, powerful gust that completely heals all wounds.", isInstantHeal: true }
                ]
            },
            chaosflare: {
                name: "Chaosflare the Stormbringer",
                element: "Chaos",
                image: "images/chaosflare.jpg",
                powers: [
                    { name: "Elemental Fusion", description: "Chaosflare can mix elements together, creating new hybrid powers like frozen fire, electric water, or shadowy light that no other dragon can master." },
                    { name: "Reality Distortion", description: "His very presence bends reality slightly, causing unpredictable color shifts in his scales and making nearby objects behave in strange ways." },
                    { name: "Chaos Blast", description: "He can unleash bursts of pure chaos energy that scramble elemental powers, temporarily disrupting other dragons' abilities in unexpected ways." },
                    { name: "Pattern Randomization", description: "Chaosflare can create beautiful, unpredictable patterns of light, energy, and color that defy logic and mesmerize those who watch them." },
                    { name: "Unpredictable Teleportation", description: "Through chaotic space manipulation, he can instantly appear anywhere in the lair, though the destination is often slightly different from where he intended." },
                    { name: "Chaotic Regeneration (Healing)", description: "Chaosflare can channel the unpredictable nature of chaos itself to twist reality around his wounds, causing them to heal in wild and unexpected ways that restore his vitality.", isHealing: true },
                    { name: "Chaos Barrier (Shield)", description: "Chaosflare can create a swirling barrier of chaotic energy that warps and deflects incoming attacks, making him unpredictable and hard to hit.", isShield: true },
                    { name: "Reality Rewrite (Instant Heal)", description: "Chaosflare can completely rewrite reality itself, instantly erasing all wounds and damage from existence, restoring himself to perfect health in an instant.", isInstantHeal: true }
                ]
            },
            crystalwing: {
                name: "Crystalwing the Prismkeeper",
                element: "Crystal",
                image: "images/crystalwing.jpg",
                powers: [
                    { name: "Memory Crystals", description: "Crystalwing can store memories and visions inside crystals she creates, allowing the lair to have a visual history of everything that happens." },
                    { name: "Prism Light Refraction", description: "Her transparent scales refract light into beautiful rainbow displays, creating stunning visual effects that can illuminate entire chambers." },
                    { name: "Crystal Growth", description: "She can grow crystals from any surface, creating structures, tools, or decorations that are both beautiful and functional." },
                    { name: "Vision Projection", description: "By touching one of her memory crystals, Crystalwing can project stored memories as visible images, allowing others to see past events." },
                    { name: "Prismatic Shield", description: "She can create crystal barriers that refract attacks, splitting incoming energy or projectiles into harmless fragments." },
                    { name: "Crystalline Restoration (Healing)", description: "Crystalwing can form healing crystals that grow from her wounds, sealing them with pure crystal that restores her vitality and makes her scales shine even brighter.", isHealing: true },
                    { name: "Crystal Barrier (Shield)", description: "Crystalwing can grow a protective crystal barrier around herself that refracts and reflects incoming attacks, shielding her with brilliant prismatic defenses.", isShield: true },
                    { name: "Perfect Prism Renewal (Instant Heal)", description: "Crystalwing can create a perfect, flawless crystal that instantly refracts pure healing energy through every part of her body, completely restoring her health in a brilliant flash of light.", isInstantHeal: true }
                ]
            },
            earthheart: {
                name: "Earthheart the Stonekeeper",
                element: "Earth",
                image: "images/earthheart.jpg",
                powers: [
                    { name: "Stone Shaping", description: "Earthheart can shape stone with his claws, creating new tunnels and rooms in the lair by simply touching the walls, reshaping the very foundation of the lair." },
                    { name: "Moss Armor", description: "His scales naturally grow moss and lichen that provide extra protection and allow him to blend seamlessly with stone surfaces." },
                    { name: "Ground Tremor", description: "By stomping his powerful feet, Earthheart can create controlled tremors that reshape terrain or serve as a warning to other dragons." },
                    { name: "Earthen Shield", description: "He can raise walls of stone from the ground to protect himself and others, creating instant fortifications when needed." },
                    { name: "Mineral Sensing", description: "Earthheart can sense valuable minerals and ores deep underground, helping Metalbeak locate the finest materials for forging." },
                    { name: "Earthen Regeneration (Healing)", description: "Earthheart can draw strength from the very earth beneath him, causing his stone-like scales to repair themselves and his wounds to seal with rich, healing soil and minerals.", isHealing: true },
                    { name: "Stone Barrier (Shield)", description: "Earthheart can raise an impenetrable wall of solid stone around himself, creating a protective barrier that absorbs and blocks incoming damage.", isShield: true },
                    { name: "Bedrock Restoration (Instant Heal)", description: "Earthheart can merge completely with the ancient bedrock itself, drawing infinite strength from the deepest earth to instantly restore all of his health to perfect condition.", isInstantHeal: true }
                ]
            },
            flamethorn: {
                name: "Flamethorn the Firebringer",
                element: "Fire",
                image: "images/flamethorn.jpg",
                powers: [
                    { name: "Eternal Flame", description: "Flamethorn can breathe fire that never burns out, creating eternal torches that light up the darkest corners of the lair without ever needing refueling." },
                    { name: "Ember Creation", description: "His wings create sparks and embers with every beat, leaving trails of glowing embers that can ignite fires or create beautiful light displays." },
                    { name: "Heat Manipulation", description: "Flamethorn can control the intensity of his flames, from gentle warmth that comforts to scorching blasts that can melt the hardest metals." },
                    { name: "Forge Fire", description: "He can produce specialized flames perfect for Metalbeak's forge work, creating fires that burn at precise temperatures for metalworking." },
                    { name: "Fire Shield", description: "Flamethorn can surround himself or others with protective walls of flame that burn enemies while keeping allies safe from the heat." },
                    { name: "Fiery Restoration (Healing)", description: "Flamethorn can channel his eternal flames inward, using their purifying heat to cauterize wounds and reignite his inner fire, restoring his strength and vitality.", isHealing: true },
                    { name: "Blazing Barrier (Shield)", description: "Flamethorn can create a protective wall of eternal flames that burns away incoming attacks, shielding him with unquenchable fire that destroys anything that touches it.", isShield: true },
                    { name: "Phoenix Rebirth (Instant Heal)", description: "Flamethorn can channel the legendary power of the phoenix, completely immolating himself in eternal flames that instantly burn away all wounds and restore him to perfect health.", isInstantHeal: true }
                ]
            },
            frostbite: {
                name: "Frostbite the Iceweaver",
                element: "Ice",
                image: "images/frostbite.jpg",
                powers: [
                    { name: "Time Freeze", description: "Frostbite can freeze time in small areas, creating frozen moments that she can examine and then release, perfect for protecting treasures or preventing disasters." },
                    { name: "Ice Sculpture", description: "Her breath creates beautiful ice sculptures that capture moments in time, forming intricate frozen artworks that never melt." },
                    { name: "Permafrost Breath", description: "Frostbite can breathe ice so cold that it creates permanent ice formations, even in the presence of heat, protecting important areas." },
                    { name: "Crystalline Shield", description: "She can create walls of ice that are harder than diamond, providing protection that reflects and refracts attacks." },
                    { name: "Flash Freeze", description: "Frostbite can instantly freeze water, objects, or even small areas of space, preserving them in perfect condition for eternity." },
                    { name: "Icy Rejuvenation (Healing)", description: "Frostbite can freeze her wounds solid, preventing further damage while her pure ice scales slowly regenerate and restore her health with the power of eternal winter.", isHealing: true },
                    { name: "Glacial Barrier (Shield)", description: "Frostbite can create an unbreakable wall of permafrost ice around herself, forming a protective barrier of eternal cold that freezes and shatters incoming attacks.", isShield: true },
                    { name: "Absolute Zero Recovery (Instant Heal)", description: "Frostbite can freeze time itself around her wounds, instantly preserving them in perfect ice that melts away to reveal completely healed, unblemished scales and full health.", isInstantHeal: true }
                ]
            },
            radiant: {
                name: "Radiant the Sunbeam",
                element: "Light",
                image: "images/radiant.jpg",
                powers: [
                    { name: "Solid Light Constructs", description: "Radiant can create solid light constructs - bridges, stairs, and walls made entirely of pure light that last for hours, building structures of pure radiance." },
                    { name: "Prismatic Wings", description: "Her wings create beautiful rainbow displays when they catch the light, producing prismatic effects that can dazzle and inspire." },
                    { name: "Guiding Light", description: "Radiant can create beams of light that guide others through darkness, leading them safely to their destination." },
                    { name: "Solar Growth", description: "She can focus her light to accelerate plant growth, helping Vineclaw's gardens flourish with enhanced photosynthesis." },
                    { name: "Light Healing", description: "Radiant's warm, golden light has gentle healing properties that can soothe wounds and restore energy to those who bask in her radiance." },
                    { name: "Solar Restoration (Healing)", description: "Radiant can channel pure sunlight into her body, filling every wound with warm, healing radiance that restores her health and makes her golden scales shine with renewed brilliance.", isHealing: true },
                    { name: "Radiant Barrier (Shield)", description: "Radiant can create a barrier of solid golden light that surrounds her, forming a protective shield of pure radiance that blinds and deflects incoming attacks.", isShield: true },
                    { name: "Divine Light Revival (Instant Heal)", description: "Radiant can channel the full power of the sun itself, becoming a beacon of pure divine light that instantly fills every wound with absolute radiance, completely restoring her health in a blinding flash.", isInstantHeal: true }
                ]
            },
            stormwing: {
                name: "Stormwing the Skybreaker",
                element: "Lightning",
                image: "images/stormwing.jpg",
                powers: [
                    { name: "Electrical Grid", description: "Stormwing can channel lightning through his wings to power crystals throughout the lair, creating a natural electrical grid that provides energy to all." },
                    { name: "Lightning Strike", description: "He can call down bolts of lightning from the sky, directing them with precision to strike targets from great distances." },
                    { name: "Thunder Clap", description: "Stormwing can create thunderous booms that shake the very foundations of the lair, serving as warnings or displays of power." },
                    { name: "Electric Conductivity", description: "His scales can store and channel electricity, allowing him to power devices or create electrical weapons on demand." },
                    { name: "Storm Summoning", description: "Stormwing can create localized storms around himself, generating powerful winds, lightning, and thunder that protect and defend." },
                    { name: "Electric Restoration (Healing)", description: "Stormwing can channel lightning through his own body, using the electrical energy to stimulate his cells and regenerate damaged tissue, restoring his health with the power of the storm.", isHealing: true },
                    { name: "Lightning Barrier (Shield)", description: "Stormwing can create a crackling barrier of electrical energy around himself, forming a protective shield of lightning that zaps and redirects incoming attacks.", isShield: true },
                    { name: "Thunderous Surge (Instant Heal)", description: "Stormwing can call down the full force of a massive thunderstorm, channeling overwhelming lightning through his entire body that instantly regenerates all damaged tissue and restores him to perfect health.", isInstantHeal: true }
                ]
            },
            metalbeak: {
                name: "Metalbeak the Forgeguard",
                element: "Metal",
                image: "images/metalbeak.jpg",
                powers: [
                    { name: "Metal Shaping", description: "Metalbeak can reshape metal with his heat alone, crafting weapons and tools without ever needing a forge or hammer, molding metal with just his touch." },
                    { name: "Unbreakable Claws", description: "His claws can cut through any material, from the hardest stone to the most resilient crystal, making him the lair's ultimate craftsman." },
                    { name: "Bell Resonance", description: "His steel-gray scales ring like bells when struck, creating beautiful musical tones that can be used for communication or celebration." },
                    { name: "Alloy Creation", description: "Metalbeak can combine different metals using his body heat, creating new alloys with unique properties never seen before." },
                    { name: "Metal Sensing", description: "He can detect and locate metal ores and deposits deep underground, working with Earthheart to mine the finest materials for forging." },
                    { name: "Metallic Repair (Healing)", description: "Metalbeak can heat his scales to forge-like temperatures, using his mastery over metal to repair damaged scales and seal wounds with molten steel that cools into perfect healing armor.", isHealing: true },
                    { name: "Steel Barrier (Shield)", description: "Metalbeak can forge an unbreakable shield of pure steel around himself, creating a protective barrier of solid metal that blocks and absorbs incoming damage.", isShield: true },
                    { name: "Perfect Forge Rebirth (Instant Heal)", description: "Metalbeak can forge himself anew in the perfect forge of his own body heat, instantly reforging every damaged scale and wound with flawless molten steel that cools into perfect health.", isInstantHeal: true }
                ]
            },
            vineclaw: {
                name: "Vineclaw the Lifegiver",
                element: "Nature",
                image: "images/vineclaw.jpg",
                powers: [
                    { name: "Living Gardens", description: "Vineclaw can create living gardens anywhere in the lair, growing food-bearing plants that never need water or sunlight, providing sustenance for all." },
                    { name: "Instant Growth", description: "Her claws can instantly grow plants from any surface, creating vines, flowers, or trees in seconds wherever she touches." },
                    { name: "Moss Armor", description: "Her scales are covered in living moss and flowers that provide natural camouflage and allow her to blend with any garden environment." },
                    { name: "Healing Pollen", description: "Vineclaw can release pollen from her flowers that has gentle healing properties, restoring energy and soothing wounds." },
                    { name: "Seed Spreading", description: "She can create and scatter seeds that grow into any plant she imagines, populating barren areas with lush vegetation in moments." },
                    { name: "Life Force Regeneration (Healing)", description: "Vineclaw can channel the very essence of life itself, causing healing vines and flowers to sprout from her wounds, drawing upon nature's infinite vitality to restore her health.", isHealing: true },
                    { name: "Thorny Barrier (Shield)", description: "Vineclaw can instantly grow a protective barrier of thick, thorny vines and brambles around herself, creating a natural shield that blocks and entangles incoming attacks.", isShield: true },
                    { name: "Nature's Ultimate Gift (Instant Heal)", description: "Vineclaw can channel the infinite life force of nature itself, causing a massive bloom of life-giving flowers and vines to instantly sprout from every wound, completely restoring her health in a single burst of pure vitality.", isInstantHeal: true }
                ]
            },
            shadowmaw: {
                name: "Shadowmaw the Nightstalker",
                element: "Shadow",
                image: "images/shadowmaw.jpg",
                powers: [
                    { name: "Shadow Meld", description: "Shadowmaw can merge with shadows to become completely invisible, allowing him to move undetected through even the brightest areas." },
                    { name: "Absolute Darkness", description: "He can create darkness so deep that even dragon fire cannot penetrate it, forming impenetrable shadow barriers." },
                    { name: "Shadow Teleportation", description: "By traveling through shadows, Shadowmaw can instantly move from one shadowed area to another anywhere in the lair." },
                    { name: "Light Absorption", description: "His scales absorb light around him, creating pockets of darkness that make nearby areas dimmer and more shadowy." },
                    { name: "Shadow Form", description: "Shadowmaw can transform parts of his body into pure shadow, allowing him to pass through small spaces or become intangible." },
                    { name: "Shadow Regeneration (Healing)", description: "Shadowmaw can merge his wounds with the darkness itself, causing them to become intangible shadows that slowly fade away as he draws strength from the endless void to restore his health.", isHealing: true },
                    { name: "Shadow Barrier (Shield)", description: "Shadowmaw can create a barrier of absolute darkness around himself, forming an impenetrable shadow shield that makes incoming attacks pass harmlessly through the void.", isShield: true },
                    { name: "Void Rebirth (Instant Heal)", description: "Shadowmaw can completely merge with the endless void itself, becoming pure shadow that instantly erases all wounds from existence and emerges from the darkness fully restored to perfect health.", isInstantHeal: true }
                ]
            },
            aquaris: {
                name: "Aquaris the Depthcaller",
                element: "Water",
                image: "images/aquaris.jpg",
                powers: [
                    { name: "Gravity-Defying Water", description: "Aquaris can breathe water that flows upward, creating waterfalls that defy gravity and fill the lair's pools from below." },
                    { name: "Whirlpool Tail", description: "Her tail can create powerful whirlpools with a single flick, capable of controlling water flow or creating defensive water barriers." },
                    { name: "Healing Waters", description: "Aquaris's water has gentle healing properties, restoring energy and soothing wounds when dragons bathe in her pools." },
                    { name: "Water Breathing", description: "She can create bubbles of breathable water, allowing other dragons to breathe underwater or survive in flooded areas." },
                    { name: "Current Control", description: "Aquaris can manipulate water currents with precision, creating flowing streams for transportation or powerful jets for defense." },
                    { name: "Aquatic Restoration (Healing)", description: "Aquaris can channel pure, life-giving water through her body, causing her wounds to wash clean and heal as if bathed in the most pristine healing springs of the deepest ocean.", isHealing: true },
                    { name: "Aquatic Barrier (Shield)", description: "Aquaris can create a protective barrier of swirling water around herself, forming a shield of flowing currents that redirects and absorbs incoming attacks with fluid grace.", isShield: true },
                    { name: "Ocean's Complete Restoration (Instant Heal)", description: "Aquaris can channel the infinite healing power of the deepest ocean itself, summoning a massive wave of pure life-giving water that instantly washes away all wounds and restores her to perfect health.", isInstantHeal: true }
                ]
            }
        };

        // Function to display selected dragon
        function displayDragon(dragonId) {
            const displayDiv = document.getElementById('dragon-display');
            const dragon = dragonData[dragonId];
            
            if (!dragon) {
                displayDiv.innerHTML = '';
                return;
            }

            let powersHTML = '<h4>Powers</h4><ol>';
            dragon.powers.forEach(function(power) {
                powersHTML += '<li><strong>' + power.name + ':</strong> ' + power.description + '</li>';
            });
            powersHTML += '</ol>';

            // Get element class for proper styling
            const elementClass = getElementClass(dragon.element);
            
            displayDiv.innerHTML = `
                <div class="selected-dragon ${elementClass}">
                    <img src="${dragon.image}" alt="${dragon.name}" />
                    <h3>${dragon.name}</h3>
                    <p class="element">Element: ${dragon.element}</p>
                    ${powersHTML}
                </div>
            `;
        }

        // Function to get element class name
        function getElementClass(element) {
            const elementMap = {
                'fire': 'fire',
                'water': 'water',
                'lightning': 'lightning',
                'earth': 'earth',
                'air': 'air',
                'ice': 'ice',
                'shadow': 'shadow',
                'light': 'light',
                'nature': 'nature',
                'metal': 'metal',
                'crystal': 'crystal',
                'chaos': 'chaos'
            };
            return elementMap[element.toLowerCase()] || '';
        }

        // Function to enable/disable start button
        function updateStartButton() {
            const dragonSelect = document.getElementById('dragon-select');
            const selected = dragonSelect.value;
            const startButton = document.getElementById('story-start-button');
            
            if (selected && selected !== '') {
                startButton.disabled = false;
            } else {
                startButton.disabled = true;
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const dragonSelect = document.getElementById('dragon-select');
            const startButton = document.getElementById('story-start-button');

            // Dragon selection
            dragonSelect.addEventListener('change', function() {
                const selected = this.value;
                
                if (selected) {
                    displayDragon(selected);
                } else {
                    document.getElementById('dragon-display').innerHTML = '';
                }
                updateStartButton();
            });

            // Start button
            startButton.addEventListener('click', function() {
                const selectedDragon = dragonSelect.value;
                if (selectedDragon) {
                    startAdventure(selectedDragon);
                }
            });

            // Back to selection button
            const backToSelectButton = document.getElementById('back-to-select-button');
            if (backToSelectButton) {
                backToSelectButton.addEventListener('click', function() {
                    // Hide adventure view
                    document.getElementById('adventure-view').classList.remove('active');
                    // Show selection area
                    document.getElementById('selection-area').classList.remove('hidden');
                    // Hide joystick
                    hideJoystick();
                    // Reset keys
                    keysPressed = { w: false, a: false, s: false, d: false };
                    // Reset joystick
                    joystickState = { active: false, x: 0, y: 0 };
                    // Reset room system (this will generate new rooms on next adventure start)
                    currentRoom = { x: 0, y: 0 };
                    roomMemory = {};
                    transitioning = false;
                    updateMap();
                    // Clear movement interval
                    if (movementInterval) {
                        clearInterval(movementInterval);
                        movementInterval = null;
                    }
                });
            }

            // Teleport to Main Room button
            const teleportMainButton = document.getElementById('teleport-main-button');
            if (teleportMainButton) {
                teleportMainButton.addEventListener('click', function() {
                    teleportToMainRoom();
                });
            }

            // Update mobile detection on window resize
            window.addEventListener('resize', function() {
                const wasMobile = isMobile;
                isMobile = window.innerWidth <= 768;
                
                // Show/hide joystick based on mobile state
                const adventureView = document.getElementById('adventure-view');
                if (adventureView && adventureView.classList.contains('active')) {
                    if (isMobile && !wasMobile) {
                        showJoystick();
                    } else if (!isMobile && wasMobile) {
                        hideJoystick();
                    }
                }
            });
        });

        // Global movement interval variable
        let movementInterval = null;
        let keyDownHandler = null;
        let keyUpHandler = null;

        // Dragon movement state
        let dragonPosition = {
            x: 50, // percentage from left
            y: 50  // pixels from bottom
        };

        let keysPressed = {
            w: false,
            a: false,
            s: false,
            d: false
        };

        // Room system with memory
        let currentRoom = { x: 0, y: 0 }; // Grid coordinates (center is 0,0)
        let roomMemory = {}; // Stores room states: { "x,y": { background, seed, visited } }
        let transitioning = false; // Prevents multiple transitions at once
        const MAX_ROOMS = 3; // Maximum rooms in each direction from center
        
        // Session seed that changes each time the game is played
        // This makes rooms different every play session
        const sessionSeed = Math.floor(Math.random() * 1000000000);

        // Joystick state
        let joystickState = {
            active: false,
            x: 0,
            y: 0
        };

        let joystickContainer = null;
        let joystickStick = null;
        let joystickBase = null;
        let joystickBaseRect = null;
        let isMobile = window.innerWidth <= 768;

        // Store current dragon for room display
        let currentDragon = null;

        // Function to start the adventure
        function startAdventure(dragonId) {
            const dragon = dragonData[dragonId];
            if (!dragon) {
                return;
            }
            
            // Clear room memory when starting a new adventure
            // This ensures fresh rooms are generated with the current session seed
            roomMemory = {};
            currentRoom = { x: 0, y: 0 };
            transitioning = false;
            
            currentDragon = dragon;

            // Hide selection area
            const selectionArea = document.getElementById('selection-area');
            if (selectionArea) {
                selectionArea.classList.add('hidden');
            }
            
            // Show adventure view
            const adventureView = document.getElementById('adventure-view');
            if (adventureView) {
                adventureView.classList.add('active');
            }

            // Update dragon name and room info
            const dragonNameElement = document.getElementById('adventure-dragon-name');
            if (dragonNameElement) {
                updateRoomDisplay();
            }

            // Display pixelated dragon
            const pixelDragon = document.getElementById('pixel-dragon');
            if (pixelDragon) {
                // Map dragon IDs to their icon images
                const dragonIcons = {
                    'breezeflight': 'images/icons/breezeflight-icon.jpg',
                    'chaosflare': 'images/icons/chacosflare-icon.jpg',
                    'crystalwing': 'images/icons/crystalwing-icon.jpg',
                    'earthheart': 'images/icons/earthheart-icon.jpg',
                    'flamethorn': 'images/icons/flamethorn-icon.jpg',
                    'frostbite': 'images/icons/frostbite-icon.jpg',
                    'metalbeak': 'images/icons/metalbeak-icon.jpg',
                    'aquaris': 'images/icons/aquarius-icon.jpg',
                    // Default icons for dragons not specified (use aquarius as fallback)
                    'radiant': 'images/icons/aquarius-icon.jpg',
                    'stormwing': 'images/icons/aquarius-icon.jpg',
                    'vineclaw': 'images/icons/aquarius-icon.jpg',
                    'shadowmaw': 'images/icons/aquarius-icon.jpg'
                };
                
                // Set the image source based on dragon ID
                const iconPath = dragonIcons[dragonId] || 'images/icons/aquarius-icon.jpg';
                pixelDragon.src = iconPath;
                pixelDragon.alt = dragon.name;
                
                // Force visibility with inline styles
                pixelDragon.style.display = 'block';
                pixelDragon.style.visibility = 'visible';
                pixelDragon.style.opacity = '1';
                pixelDragon.style.zIndex = '100';
                pixelDragon.style.position = 'absolute';
                
                // Initialize room system
                currentRoom = { x: 0, y: 0 };
                const roomKey = getRoomKey(currentRoom);
                if (!roomMemory[roomKey]) {
                    roomMemory[roomKey] = generateRoomState(currentRoom);
                }
                loadRoom(currentRoom);
                updateMap();
                
                // Reset position to center of cave (check for collision first)
                let spawnX = 50;
                let spawnY = 100;
                const caveBackground = document.querySelector('.cave-background');
                if (caveBackground) {
                    const safePosition = findSafeSpawnPosition(spawnX, spawnY, null, caveBackground.offsetWidth, caveBackground.offsetHeight);
                    dragonPosition = { x: safePosition.x, y: safePosition.y };
                } else {
                    dragonPosition = { x: spawnX, y: spawnY };
                }
                updateDragonPosition();
                
                // Force a reflow to ensure rendering
                void pixelDragon.offsetHeight;
                
                // Log for debugging
                console.log('Dragon initialized:', dragonId, pixelDragon.src);
            }

            // Show joystick on mobile
            if (isMobile) {
                showJoystick();
            }

            // Set up keyboard controls with a small delay to ensure view is rendered
            setTimeout(function() {
                setupMovementControls();
            }, 100);
        }

        // Function to set up movement controls
        function setupMovementControls() {
            // Clear any existing interval
            if (movementInterval) {
                clearInterval(movementInterval);
                movementInterval = null;
            }

            // Remove old listeners if they exist
            if (keyDownHandler) {
                document.removeEventListener('keydown', keyDownHandler);
            }
            if (keyUpHandler) {
                document.removeEventListener('keyup', keyUpHandler);
            }

            // Key down event handler
            keyDownHandler = function(event) {
                const key = event.key.toLowerCase();
                if (key === 'w' || key === 'a' || key === 's' || key === 'd') {
                    if (document.getElementById('adventure-view').classList.contains('active')) {
                        keysPressed[key] = true;
                        event.preventDefault();
                    }
                }
            };

            // Key up event handler
            keyUpHandler = function(event) {
                const key = event.key.toLowerCase();
                if (key === 'w' || key === 'a' || key === 's' || key === 'd') {
                    keysPressed[key] = false;
                    event.preventDefault();
                }
            };

            // Add new listeners
            document.addEventListener('keydown', keyDownHandler);
            document.addEventListener('keyup', keyUpHandler);

            // Movement loop
            movementInterval = setInterval(function() {
                const adventureView = document.getElementById('adventure-view');
                if (!adventureView || !adventureView.classList.contains('active')) {
                    if (movementInterval) {
                        clearInterval(movementInterval);
                        movementInterval = null;
                    }
                    return;
                }

                const moveSpeed = 5; // pixels per frame (increased for faster movement)
                const caveBackground = document.querySelector('.cave-background');
                if (!caveBackground) return;

                const caveWidth = caveBackground.offsetWidth;
                const caveHeight = caveBackground.offsetHeight;
                const dragonWidth = 80; // dragon width in pixels
                const dragonHeight = 80; // dragon height in pixels

                let moved = false;

                // Check if using joystick (mobile) or keyboard
                if (joystickState.active && isMobile) {
                    // Use joystick input
                    const joystickX = joystickState.x;
                    const joystickY = joystickState.y;
                    
                    // Calculate movement based on joystick position
                    if (Math.abs(joystickX) > 0.1 || Math.abs(joystickY) > 0.1) {
                        // Move based on joystick direction
                        const speed = Math.sqrt(joystickX * joystickX + joystickY * joystickY);
                        const normalizedSpeed = Math.min(speed, 1);
                        
                        // Move up (joystick Y is positive)
                        if (joystickY > 0) {
                            if (dragonPosition.y < (caveHeight - dragonHeight - 10)) {
                                const newY = dragonPosition.y + moveSpeed * normalizedSpeed * joystickY;
                                if (!checkCollision(dragonPosition.x, newY)) {
                                    dragonPosition.y = newY;
                                    moved = true;
                                }
                            } else if (!transitioning && canMoveInDirection('up')) {
                                // Hit top wall - transition to room above (if allowed)
                                transitionToRoom('up');
                            }
                        }
                        // Move down (joystick Y is negative)
                        if (joystickY < 0) {
                            if (dragonPosition.y > 10) {
                                const newY = dragonPosition.y + moveSpeed * normalizedSpeed * joystickY;
                                if (!checkCollision(dragonPosition.x, newY)) {
                                    dragonPosition.y = newY;
                                    moved = true;
                                }
                            } else if (!transitioning && canMoveInDirection('down')) {
                                // Hit bottom wall - transition to room below (if allowed)
                                transitionToRoom('down');
                            }
                        }
                        // Move left (joystick X is negative)
                        if (joystickX < 0) {
                            if (dragonPosition.x > 3) {
                                const newX = dragonPosition.x + (moveSpeed * normalizedSpeed * joystickX * 100) / caveWidth;
                                if (!checkCollision(newX, dragonPosition.y)) {
                                    dragonPosition.x = newX;
                                    moved = true;
                                }
                            } else if (!transitioning && canMoveInDirection('left')) {
                                // Hit left wall - transition to room to the left (if allowed)
                                transitionToRoom('left');
                            }
                        }
                        // Move right (joystick X is positive)
                        if (joystickX > 0) {
                            if (dragonPosition.x < 97) {
                                const newX = dragonPosition.x + (moveSpeed * normalizedSpeed * joystickX * 100) / caveWidth;
                                if (!checkCollision(newX, dragonPosition.y)) {
                                    dragonPosition.x = newX;
                                    moved = true;
                                }
                            } else if (!transitioning && canMoveInDirection('right')) {
                                // Hit right wall - transition to room to the right (if allowed)
                                transitionToRoom('right');
                            }
                        }
                    }
                } else {
                    // Use keyboard input
                    // W - Move up (increase bottom value)
                    if (keysPressed.w) {
                        if (dragonPosition.y < (caveHeight - dragonHeight - 10)) {
                            const newY = dragonPosition.y + moveSpeed;
                            if (!checkCollision(dragonPosition.x, newY)) {
                                dragonPosition.y = newY;
                                moved = true;
                            }
                        } else if (!transitioning && canMoveInDirection('up')) {
                            // Hit top wall - transition to room above (if allowed)
                            transitionToRoom('up');
                        }
                    }
                    // S - Move down (decrease bottom value)
                    if (keysPressed.s) {
                        if (dragonPosition.y > 10) {
                            const newY = dragonPosition.y - moveSpeed;
                            if (!checkCollision(dragonPosition.x, newY)) {
                                dragonPosition.y = newY;
                                moved = true;
                            }
                        } else if (!transitioning && canMoveInDirection('down')) {
                            // Hit bottom wall - transition to room below (if allowed)
                            transitionToRoom('down');
                        }
                    }
                    // A - Move left (decrease x percentage)
                    if (keysPressed.a) {
                        if (dragonPosition.x > 3) {
                            const newX = dragonPosition.x - (moveSpeed * 100) / caveWidth;
                            if (!checkCollision(newX, dragonPosition.y)) {
                                dragonPosition.x = newX;
                                moved = true;
                            }
                        } else if (!transitioning && canMoveInDirection('left')) {
                            // Hit left wall - transition to room to the left (if allowed)
                            transitionToRoom('left');
                        }
                    }
                    // D - Move right (increase x percentage)
                    if (keysPressed.d) {
                        if (dragonPosition.x < 97) {
                            const newX = dragonPosition.x + (moveSpeed * 100) / caveWidth;
                            if (!checkCollision(newX, dragonPosition.y)) {
                                dragonPosition.x = newX;
                                moved = true;
                            }
                        } else if (!transitioning && canMoveInDirection('right')) {
                            // Hit right wall - transition to room to the right (if allowed)
                            transitionToRoom('right');
                        }
                    }
                }

                if (moved) {
                    updateDragonPosition();
                }
            }, 16); // ~60 FPS
        }

        // Function to update dragon position
        function updateDragonPosition() {
            const pixelDragon = document.getElementById('pixel-dragon');
            if (pixelDragon) {
                // Use left positioning with transform for centering
                pixelDragon.style.left = dragonPosition.x + '%';
                pixelDragon.style.bottom = dragonPosition.y + 'px';
                pixelDragon.style.transform = 'translateX(-50%)';
                pixelDragon.style.position = 'absolute';
                pixelDragon.style.display = 'block';
                pixelDragon.style.visibility = 'visible';
            }
        }

        // Room system functions
        function getRoomKey(roomCoord) {
            return roomCoord.x + ',' + roomCoord.y;
        }

        function generateRoomState(roomCoord) {
            // Generate a unique seed based on room coordinates AND session seed
            // This makes rooms consistent within a session but different each play session
            const seed = ((roomCoord.x * 1000 + roomCoord.y) * 12345) + sessionSeed;
            const rng = seededRandom(seed);
            
            // Room background color variations
            const backgrounds = [
                { base: '#2a2a3e', accent1: '#3a3a4e', accent2: '#4a4a5e', light: '#5a5a6e' },
                { base: '#1a2a3e', accent1: '#2a3a4e', accent2: '#3a4a5e', light: '#4a5a6e' },
                { base: '#3a2a2e', accent1: '#4a3a3e', accent2: '#5a4a4e', light: '#6a5a5e' },
                { base: '#2a3a2e', accent1: '#3a4a3e', accent2: '#4a5a4e', light: '#5a6a5e' },
                { base: '#3e2a3e', accent1: '#4e3a4e', accent2: '#5e4a5e', light: '#6e5a6e' },
                { base: '#2e3a3e', accent1: '#3e4a4e', accent2: '#4e5a5e', light: '#5e6a6e' }
            ];
            
            const bgIndex = Math.floor(rng() * backgrounds.length);
            const background = backgrounds[bgIndex];
            
            // Generate a clear path through the room with turns (L-shaped path)
            // Path goes from the wall closest to main room to the wall farthest from main room
            // Path is 120px wide (enough for 80px dragon with buffer)
            const caveWidthPx = 1200; // approximate width
            const caveHeightPx = 500; // approximate height
            const pathWidth = 120; // Path width in pixels (enough for dragon + buffer)
            const pathWidthPercent = (pathWidth / caveWidthPx) * 100; // ~10%
            
            let clearPath = null;
            
            // Determine entry direction based on room position relative to main room (0,0)
            // Rooms are on axes only (x=0 OR y=0), so we can determine the entry wall
            if (roomCoord.y > 0) {
                // Room is above main room - entered from bottom, path should go bottom to top (vertical with turn)
                // L-shaped: go up partway, then turn left or right, then continue to top
                const turnPoint = rng() * 0.4 + 0.3; // Turn between 30% and 70% up the room
                const firstSegmentX = rng() * (100 - pathWidthPercent) + pathWidthPercent / 2; // Random X for first segment
                const turnDirection = rng() > 0.5 ? 1 : -1; // Turn left (-1) or right (1)
                const turnAmount = rng() * 30 + 20; // Turn 20-50% of width
                const secondSegmentX = Math.max(pathWidthPercent / 2, Math.min(100 - pathWidthPercent / 2, firstSegmentX + turnDirection * turnAmount));
                
                clearPath = {
                    type: 'lshape',
                    segments: [
                        {
                            type: 'vertical',
                            x: firstSegmentX, // X position in percentage
                            width: pathWidthPercent,
                            minY: 0,
                            maxY: caveHeightPx * turnPoint // From bottom to turn point
                        },
                        {
                            type: 'horizontal',
                            y: caveHeightPx * turnPoint, // Y position at turn point
                            width: pathWidth,
                            minX: Math.min(firstSegmentX, secondSegmentX) - pathWidthPercent / 2,
                            maxX: Math.max(firstSegmentX, secondSegmentX) + pathWidthPercent / 2 // Horizontal segment for turn
                        },
                        {
                            type: 'vertical',
                            x: secondSegmentX, // X position in percentage
                            width: pathWidthPercent,
                            minY: caveHeightPx * turnPoint,
                            maxY: caveHeightPx // From turn point to top
                        }
                    ]
                };
            } else if (roomCoord.y < 0) {
                // Room is below main room - entered from top, path should go top to bottom (vertical with turn)
                // L-shaped: go down partway, then turn left or right, then continue to bottom
                const turnPoint = rng() * 0.4 + 0.3; // Turn between 30% and 70% down the room
                const firstSegmentX = rng() * (100 - pathWidthPercent) + pathWidthPercent / 2; // Random X for first segment
                const turnDirection = rng() > 0.5 ? 1 : -1; // Turn left (-1) or right (1)
                const turnAmount = rng() * 30 + 20; // Turn 20-50% of width
                const secondSegmentX = Math.max(pathWidthPercent / 2, Math.min(100 - pathWidthPercent / 2, firstSegmentX + turnDirection * turnAmount));
                
                clearPath = {
                    type: 'lshape',
                    segments: [
                        {
                            type: 'vertical',
                            x: firstSegmentX, // X position in percentage
                            width: pathWidthPercent,
                            minY: caveHeightPx * turnPoint,
                            maxY: caveHeightPx // From top to turn point
                        },
                        {
                            type: 'horizontal',
                            y: caveHeightPx * turnPoint, // Y position at turn point
                            width: pathWidth,
                            minX: Math.min(firstSegmentX, secondSegmentX) - pathWidthPercent / 2,
                            maxX: Math.max(firstSegmentX, secondSegmentX) + pathWidthPercent / 2 // Horizontal segment for turn
                        },
                        {
                            type: 'vertical',
                            x: secondSegmentX, // X position in percentage
                            width: pathWidthPercent,
                            minY: 0,
                            maxY: caveHeightPx * turnPoint // From turn point to bottom
                        }
                    ]
                };
            } else if (roomCoord.x > 0) {
                // Room is to the right of main room - entered from left, path should go left to right (horizontal with turn)
                // L-shaped: go right partway, then turn up or down, then continue to right
                const turnPoint = rng() * 0.4 + 0.3; // Turn between 30% and 70% across the room
                const firstSegmentY = rng() * (caveHeightPx - pathWidth) + pathWidth / 2; // Random Y for first segment
                const turnDirection = rng() > 0.5 ? 1 : -1; // Turn up (1) or down (-1)
                const turnAmount = rng() * 150 + 100; // Turn 100-250px
                const secondSegmentY = Math.max(pathWidth / 2, Math.min(caveHeightPx - pathWidth / 2, firstSegmentY + turnDirection * turnAmount));
                
                clearPath = {
                    type: 'lshape',
                    segments: [
                        {
                            type: 'horizontal',
                            y: firstSegmentY, // Y position in pixels from bottom
                            width: pathWidth,
                            minX: 0,
                            maxX: turnPoint * 100 // From left to turn point
                        },
                        {
                            type: 'vertical',
                            x: turnPoint * 100, // X position at turn point
                            width: pathWidthPercent,
                            minY: Math.min(firstSegmentY, secondSegmentY) - pathWidth / 2,
                            maxY: Math.max(firstSegmentY, secondSegmentY) + pathWidth / 2 // Vertical segment for turn
                        },
                        {
                            type: 'horizontal',
                            y: secondSegmentY, // Y position in pixels from bottom
                            width: pathWidth,
                            minX: turnPoint * 100,
                            maxX: 100 // From turn point to right
                        }
                    ]
                };
            } else if (roomCoord.x < 0) {
                // Room is to the left of main room - entered from right, path should go right to left (horizontal with turn)
                // L-shaped: go left partway, then turn up or down, then continue to left
                const turnPoint = rng() * 0.4 + 0.3; // Turn between 30% and 70% across the room
                const firstSegmentY = rng() * (caveHeightPx - pathWidth) + pathWidth / 2; // Random Y for first segment
                const turnDirection = rng() > 0.5 ? 1 : -1; // Turn up (1) or down (-1)
                const turnAmount = rng() * 150 + 100; // Turn 100-250px
                const secondSegmentY = Math.max(pathWidth / 2, Math.min(caveHeightPx - pathWidth / 2, firstSegmentY + turnDirection * turnAmount));
                
                clearPath = {
                    type: 'lshape',
                    segments: [
                        {
                            type: 'horizontal',
                            y: firstSegmentY, // Y position in pixels from bottom
                            width: pathWidth,
                            minX: turnPoint * 100,
                            maxX: 100 // From right to turn point
                        },
                        {
                            type: 'vertical',
                            x: turnPoint * 100, // X position at turn point
                            width: pathWidthPercent,
                            minY: Math.min(firstSegmentY, secondSegmentY) - pathWidth / 2,
                            maxY: Math.max(firstSegmentY, secondSegmentY) + pathWidth / 2 // Vertical segment for turn
                        },
                        {
                            type: 'horizontal',
                            y: secondSegmentY, // Y position in pixels from bottom
                            width: pathWidth,
                            minX: 0,
                            maxX: turnPoint * 100 // From turn point to left
                        }
                    ]
                };
            } else {
                // Main room (0,0) - no path needed (no obstacles)
                clearPath = null;
            }
            
            // Generate obstacles (10-50 obstacles per room, excluding main room)
            const obstacles = [];
            const numObstacles = roomCoord.x === 0 && roomCoord.y === 0 ? 0 : Math.floor(rng() * 41) + 10;
            const obstacleTypes = ['rock', 'crystal', 'stalagmite'];
            
            for (let i = 0; i < numObstacles; i++) {
                let attempts = 0;
                let validPosition = false;
                let x, y, size, type;
                
                // Try to find a valid position that doesn't block the clear path
                while (!validPosition && attempts < 200) {
                    attempts++;
                    
                    // Generate random position anywhere in the room
                    x = rng() * 100; // 0% to 100% of width
                    y = rng() * 500; // 0 to 500px from bottom
                    size = Math.floor(rng() * 30) + 20; // 20px to 50px
                    type = obstacleTypes[Math.floor(rng() * obstacleTypes.length)];
                    
                    // Convert obstacle bounds
                    const sizePercent = (size / caveWidthPx) * 100;
                    const obstacleLeft = x - sizePercent / 2;
                    const obstacleRight = x + sizePercent / 2;
                    const obstacleBottom = y - size / 2; // from bottom
                    const obstacleTop = y + size / 2; // from bottom
                    
                    // Check if obstacle overlaps with the clear path
                    let blocksPath = false;
                    
                    if (clearPath.type === 'horizontal') {
                        // Horizontal path: check if obstacle is within path height range
                        const pathTop = clearPath.y + clearPath.width / 2;
                        const pathBottom = clearPath.y - clearPath.width / 2;
                        blocksPath = (obstacleTop > pathBottom && obstacleBottom < pathTop);
                    } else if (clearPath.type === 'vertical') {
                        // Vertical path: check if obstacle is within path width range
                        const pathLeft = clearPath.x - clearPath.width / 2;
                        const pathRight = clearPath.x + clearPath.width / 2;
                        blocksPath = (obstacleRight > pathLeft && obstacleLeft < pathRight);
                    } else if (clearPath.type === 'diagonal') {
                        // Diagonal path: check if obstacle is close to the diagonal line
                        // For simplicity, we'll use a wider diagonal band
                        const diagonalWidth = clearPath.widthPercent * 2; // Wider tolerance for diagonal
                        
                        // Calculate distance from obstacle center to diagonal line
                        // Diagonal goes from corner to opposite corner
                        let distanceToDiagonal = 0;
                        if (clearPath.startSide === 0) { // top-left to bottom-right
                            // Line: y = (height/width) * x converted to percentage/pixel coordinates
                            const diagonalY = (caveHeightPx / 100) * x;
                            distanceToDiagonal = Math.abs(y - diagonalY);
                        } else if (clearPath.startSide === 1) { // top-right to bottom-left
                            const diagonalY = caveHeightPx - (caveHeightPx / 100) * x;
                            distanceToDiagonal = Math.abs(y - diagonalY);
                        } else if (clearPath.startSide === 2) { // bottom-left to top-right
                            const diagonalY = (caveHeightPx / 100) * x;
                            distanceToDiagonal = Math.abs(y - diagonalY);
                        } else { // bottom-right to top-left
                            const diagonalY = caveHeightPx - (caveHeightPx / 100) * x;
                            distanceToDiagonal = Math.abs(y - diagonalY);
                        }
                        
                        // Check if obstacle is within diagonal path width
                        const pathRadius = clearPath.width / 2;
                        blocksPath = (distanceToDiagonal < pathRadius + size / 2);
                    }
                    
                    // Position is valid if it doesn't block the clear path
                    validPosition = !blocksPath;
                }
                
                // If we found a valid position, add the obstacle
                if (validPosition) {
                    obstacles.push({
                        x: x, // percentage
                        y: y, // pixels from bottom
                        width: size,
                        height: size,
                        type: type
                    });
                }
            }
            
            return {
                seed: seed,
                background: background,
                obstacles: obstacles,
                clearPath: clearPath, // Store the clear path
                visited: false
            };
        }

        // Seeded random number generator for consistent room generation
        function seededRandom(seed) {
            let value = seed;
            return function() {
                value = (value * 9301 + 49297) % 233280;
                return value / 233280;
            };
        }

        // Check if obstacles block any paths
        function pathsBlocked(obstacles, clearPath) {
            if (!obstacles || obstacles.length === 0 || !clearPath) return false;
            
            const caveWidthPx = 1200;
            const caveHeightPx = 500;
            
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                const sizePercent = (obstacle.width / caveWidthPx) * 100;
                const obstacleLeft = obstacle.x - sizePercent / 2;
                const obstacleRight = obstacle.x + sizePercent / 2;
                const obstacleBottom = obstacle.y - obstacle.height / 2;
                const obstacleTop = obstacle.y + obstacle.height / 2;
                
                // Check if obstacle blocks any segment of the clear path
                if (clearPath.type === 'lshape' && clearPath.segments) {
                    for (let segIdx = 0; segIdx < clearPath.segments.length; segIdx++) {
                        const segment = clearPath.segments[segIdx];
                        
                        if (segment.type === 'horizontal') {
                            const pathTop = segment.y + segment.width / 2;
                            const pathBottom = segment.y - segment.width / 2;
                            const pathLeft = segment.minX;
                            const pathRight = segment.maxX;
                            if (obstacleTop > pathBottom && obstacleBottom < pathTop &&
                                obstacleRight > pathLeft && obstacleLeft < pathRight) {
                                return true; // Path is blocked
                            }
                        } else if (segment.type === 'vertical') {
                            const pathLeft = segment.x - segment.width / 2;
                            const pathRight = segment.x + segment.width / 2;
                            const pathBottom = segment.minY;
                            const pathTop = segment.maxY;
                            if (obstacleRight > pathLeft && obstacleLeft < pathRight &&
                                obstacleTop > pathBottom && obstacleBottom < pathTop) {
                                return true; // Path is blocked
                            }
                        }
                    }
                } else if (clearPath.type === 'horizontal') {
                    const pathTop = clearPath.y + clearPath.width / 2;
                    const pathBottom = clearPath.y - clearPath.width / 2;
                    if (obstacleTop > pathBottom && obstacleBottom < pathTop) {
                        return true; // Path is blocked
                    }
                } else if (clearPath.type === 'vertical') {
                    const pathLeft = clearPath.x - clearPath.width / 2;
                    const pathRight = clearPath.x + clearPath.width / 2;
                    if (obstacleRight > pathLeft && obstacleLeft < pathRight) {
                        return true; // Path is blocked
                    }
                }
            }
            
            return false; // No paths blocked
        }

        function loadRoom(roomCoord) {
            const roomKey = getRoomKey(roomCoord);
            if (!roomMemory[roomKey]) {
                roomMemory[roomKey] = generateRoomState(roomCoord);
            }
            
            const room = roomMemory[roomKey];
            
            // Ensure room has obstacles if it's not the main room, and regenerate if paths are blocked
            if ((roomCoord.x !== 0 || roomCoord.y !== 0) && 
                (!room.obstacles || room.obstacles.length < 10 || !room.clearPath || pathsBlocked(room.obstacles || [], room.clearPath))) {
                // Regenerate obstacles - first ensure we have a clear path
                // If room doesn't have a clear path, regenerate the entire room state
                if (!room.clearPath) {
                    // Regenerate entire room to get a clear path
                    roomMemory[roomKey] = generateRoomState(roomCoord);
                    loadRoom(roomCoord); // Recursive call to load the new room
                    return;
                }
                
                const seed = ((roomCoord.x * 1000 + roomCoord.y) * 12345) + sessionSeed;
                const rng = seededRandom(seed);
                const obstacles = [];
                const numObstacles = Math.floor(rng() * 41) + 10; // 10-50 obstacles
                const obstacleTypes = ['rock', 'crystal', 'stalagmite'];
                
                const caveWidthPx = 1200; // approximate width
                const caveHeightPx = 500; // approximate height
                const clearPath = room.clearPath; // Use existing clear path
                
                for (let i = 0; i < numObstacles; i++) {
                    let attempts = 0;
                    let validPosition = false;
                    let x, y, size, type;
                    
                    // Try to find a valid position that doesn't block the clear path
                    while (!validPosition && attempts < 200) {
                        attempts++;
                        
                        // Generate random position anywhere in the room
                        x = rng() * 100; // 0% to 100% of width
                        y = rng() * 500; // 0 to 500px from bottom
                        size = Math.floor(rng() * 30) + 20; // 20px to 50px
                        type = obstacleTypes[Math.floor(rng() * obstacleTypes.length)];
                        
                        // Convert obstacle bounds
                        const sizePercent = (size / caveWidthPx) * 100;
                        const obstacleLeft = x - sizePercent / 2;
                        const obstacleRight = x + sizePercent / 2;
                        const obstacleBottom = y - size / 2; // from bottom
                        const obstacleTop = y + size / 2; // from bottom
                        
                        // Check if obstacle overlaps with the clear path segments
                        let blocksPath = false;
                        
                        if (clearPath.type === 'lshape' && clearPath.segments) {
                            // L-shaped path: check each segment
                            for (let segIdx = 0; segIdx < clearPath.segments.length; segIdx++) {
                                const segment = clearPath.segments[segIdx];
                                
                                if (segment.type === 'horizontal') {
                                    // Horizontal segment: check if obstacle is within path height range
                                    const pathTop = segment.y + segment.width / 2;
                                    const pathBottom = segment.y - segment.width / 2;
                                    const pathLeft = segment.minX;
                                    const pathRight = segment.maxX;
                                    if (obstacleTop > pathBottom && obstacleBottom < pathTop &&
                                        obstacleRight > pathLeft && obstacleLeft < pathRight) {
                                        blocksPath = true;
                                        break;
                                    }
                                } else if (segment.type === 'vertical') {
                                    // Vertical segment: check if obstacle is within path width range
                                    const pathLeft = segment.x - segment.width / 2;
                                    const pathRight = segment.x + segment.width / 2;
                                    const pathBottom = segment.minY;
                                    const pathTop = segment.maxY;
                                    if (obstacleRight > pathLeft && obstacleLeft < pathRight &&
                                        obstacleTop > pathBottom && obstacleBottom < pathTop) {
                                        blocksPath = true;
                                        break;
                                    }
                                }
                            }
                        } else if (clearPath.type === 'horizontal') {
                            // Horizontal path: check if obstacle is within path height range
                            const pathTop = clearPath.y + clearPath.width / 2;
                            const pathBottom = clearPath.y - clearPath.width / 2;
                            blocksPath = (obstacleTop > pathBottom && obstacleBottom < pathTop);
                        } else if (clearPath.type === 'vertical') {
                            // Vertical path: check if obstacle is within path width range
                            const pathLeft = clearPath.x - clearPath.width / 2;
                            const pathRight = clearPath.x + clearPath.width / 2;
                            blocksPath = (obstacleRight > pathLeft && obstacleLeft < pathRight);
                        }
                        
                        // Position is valid if it doesn't block the clear path
                        validPosition = !blocksPath;
                    }
                    
                    // If we found a valid position, add the obstacle
                    if (validPosition) {
                        obstacles.push({
                            x: x, // percentage
                            y: y, // pixels from bottom
                            width: size,
                            height: size,
                            type: type
                        });
                    }
                }
                
                room.obstacles = obstacles;
            }
            
            const caveBackground = document.querySelector('.cave-background');
            
            if (caveBackground && room.background) {
                // Update room background with stored colors
                caveBackground.style.background = 
                    `repeating-linear-gradient(90deg, 
                        ${room.background.accent1} 0px, ${room.background.accent1} 16px,
                        ${room.background.base} 16px, ${room.background.base} 32px),
                    repeating-linear-gradient(0deg,
                        ${room.background.accent2} 0px, ${room.background.accent2} 16px,
                        ${room.background.accent1} 16px, ${room.background.accent1} 32px),
                    radial-gradient(ellipse at top, ${room.background.light} 0%, transparent 50%)`;
                caveBackground.style.backgroundColor = room.background.base;
            }
            
            // Render obstacles for this room
            renderObstacles(room.obstacles || []);
            
            room.visited = true;
        }

        function renderObstacles(obstacles) {
            // Remove existing obstacles
            const caveBackground = document.querySelector('.cave-background');
            if (!caveBackground) return;
            
            // Remove old obstacles
            const oldObstacles = caveBackground.querySelectorAll('.obstacle');
            oldObstacles.forEach(obs => obs.remove());
            
            // Create new obstacles
            obstacles.forEach(function(obstacle, index) {
                const obstacleEl = document.createElement('div');
                obstacleEl.className = 'obstacle ' + obstacle.type;
                obstacleEl.style.left = obstacle.x + '%';
                obstacleEl.style.bottom = obstacle.y + 'px';
                obstacleEl.style.width = obstacle.width + 'px';
                obstacleEl.style.height = obstacle.height + 'px';
                obstacleEl.style.transform = 'translateX(-50%)';
                obstacleEl.setAttribute('data-obstacle-index', index);
                caveBackground.appendChild(obstacleEl);
            });
        }

        function checkCollision(newX, newY) {
            const caveBackground = document.querySelector('.cave-background');
            if (!caveBackground) return false;
            
            const roomKey = getRoomKey(currentRoom);
            const room = roomMemory[roomKey];
            if (!room || !room.obstacles) return false;
            
            const dragonWidth = 80;
            const dragonHeight = 80;
            const caveWidth = caveBackground.offsetWidth;
            const caveHeight = caveBackground.offsetHeight;
            
            // Convert dragon position to pixels
            const dragonLeft = (newX / 100) * caveWidth - dragonWidth / 2;
            const dragonRight = dragonLeft + dragonWidth;
            const dragonTop = caveHeight - newY - dragonHeight;
            const dragonBottom = dragonTop + dragonHeight;
            
            // Check collision with each obstacle
            for (let i = 0; i < room.obstacles.length; i++) {
                const obstacle = room.obstacles[i];
                const obstacleLeft = (obstacle.x / 100) * caveWidth - obstacle.width / 2;
                const obstacleRight = obstacleLeft + obstacle.width;
                const obstacleTop = caveHeight - obstacle.y - obstacle.height;
                const obstacleBottom = obstacleTop + obstacle.height;
                
                // Check for overlap
                if (dragonLeft < obstacleRight && dragonRight > obstacleLeft &&
                    dragonTop < obstacleBottom && dragonBottom > obstacleTop) {
                    return true; // Collision detected
                }
            }
            
            return false; // No collision
        }

        function findSafeSpawnPosition(initialX, initialY, direction, caveWidth, caveHeight) {
            // Try the initial position first
            if (!checkCollision(initialX, initialY)) {
                return { x: initialX, y: initialY };
            }
            
            // If initial position has collision, try nearby positions
            const dragonWidth = 80;
            const dragonHeight = 80;
            const offsetX = (dragonWidth / caveWidth) * 100; // Convert to percentage
            const offsetY = dragonHeight; // In pixels
            
            // Try positions in a spiral pattern around the initial position
            const attempts = [
                // Try slightly offset positions
                { x: initialX + offsetX, y: initialY },
                { x: initialX - offsetX, y: initialY },
                { x: initialX, y: initialY + offsetY },
                { x: initialX, y: initialY - offsetY },
                // Try diagonal positions
                { x: initialX + offsetX, y: initialY + offsetY },
                { x: initialX - offsetX, y: initialY + offsetY },
                { x: initialX + offsetX, y: initialY - offsetY },
                { x: initialX - offsetX, y: initialY - offsetY },
                // Try positions along the wall based on direction
            ];
            
            // Add direction-specific safe positions
            switch(direction) {
                case 'up':
                    // Bottom wall - try positions along the bottom
                    attempts.push({ x: 50, y: 30 });
                    attempts.push({ x: 50, y: 50 });
                    attempts.push({ x: 40, y: 30 });
                    attempts.push({ x: 60, y: 30 });
                    break;
                case 'down':
                    // Top wall - try positions along the top
                    attempts.push({ x: 50, y: caveHeight - 130 });
                    attempts.push({ x: 50, y: caveHeight - 150 });
                    attempts.push({ x: 40, y: caveHeight - 130 });
                    attempts.push({ x: 60, y: caveHeight - 130 });
                    break;
                case 'left':
                    // Right wall - try positions along the right
                    attempts.push({ x: 85, y: 100 });
                    attempts.push({ x: 85, y: 150 });
                    attempts.push({ x: 85, y: 50 });
                    break;
                case 'right':
                    // Left wall - try positions along the left
                    attempts.push({ x: 15, y: 100 });
                    attempts.push({ x: 15, y: 150 });
                    attempts.push({ x: 15, y: 50 });
                    break;
            }
            
            // Try each position
            for (let i = 0; i < attempts.length; i++) {
                const pos = attempts[i];
                // Ensure position is within bounds
                if (pos.x >= 5 && pos.x <= 95 && pos.y >= 20 && pos.y <= caveHeight - 80) {
                    if (!checkCollision(pos.x, pos.y)) {
                        return pos;
                    }
                }
            }
            
            // If all attempts fail, return a safe default position (center, slightly offset)
            return { x: 50, y: 150 };
        }

        function teleportToMainRoom() {
            // Only teleport if not already in main room
            if (currentRoom.x === 0 && currentRoom.y === 0) {
                return; // Already in main room
            }

            // Prevent transition during teleport
            if (transitioning) {
                transitioning = false;
            }

            // Set current room to main room
            currentRoom = { x: 0, y: 0 };

            // Load the main room
            loadRoom(currentRoom);
            updateMap();
            updateRoomDisplay();

            // Position dragon in center of main room
            const caveBackground = document.querySelector('.cave-background');
            if (caveBackground) {
                const caveWidth = caveBackground.offsetWidth;
                const caveHeight = caveBackground.offsetHeight;
                
                // Find a safe spawn position in the center
                const safePosition = findSafeSpawnPosition(50, 100, null, caveWidth, caveHeight);
                dragonPosition.x = safePosition.x;
                dragonPosition.y = safePosition.y;
            } else {
                dragonPosition = { x: 50, y: 100 };
            }

            updateDragonPosition();
        }

        function isValidRoom(roomCoord) {
            // Only allow rooms that are branches from main room (on axes: x=0 OR y=0)
            // Main room (0,0) is always valid
            if (roomCoord.x === 0 && roomCoord.y === 0) {
                return true;
            }
            // Rooms on axes are valid (x=0 OR y=0, but not both non-zero)
            return (roomCoord.x === 0 || roomCoord.y === 0);
        }

        function canMoveInDirection(direction) {
            // Calculate where we would move to
            let newRoom = { x: currentRoom.x, y: currentRoom.y };
            
            switch(direction) {
                case 'up':
                    newRoom.y = currentRoom.y + 1;
                    break;
                case 'down':
                    newRoom.y = currentRoom.y - 1;
                    break;
                case 'left':
                    newRoom.x = currentRoom.x - 1;
                    break;
                case 'right':
                    newRoom.x = currentRoom.x + 1;
                    break;
                default:
                    return false;
            }
            
            // Check if the new room is valid and within bounds
            if (!isValidRoom(newRoom)) {
                return false;
            }
            
            // Check bounds (within 3 rooms from center)
            switch(direction) {
                case 'up':
                    return newRoom.y <= MAX_ROOMS;
                case 'down':
                    return newRoom.y >= -MAX_ROOMS;
                case 'left':
                    return newRoom.x >= -MAX_ROOMS;
                case 'right':
                    return newRoom.x <= MAX_ROOMS;
                default:
                    return false;
            }
        }

        function transitionToRoom(direction) {
            if (transitioning) return;
            
            // Check if movement is allowed
            if (!canMoveInDirection(direction)) {
                // Can't move further - just prevent movement, don't teleport
                transitioning = false;
                return;
            }
            
            transitioning = true;
            
            // Calculate new room coordinates based on direction
            let newRoom = { x: currentRoom.x, y: currentRoom.y };
            
            switch(direction) {
                case 'up':
                    newRoom.y = currentRoom.y + 1;
                    break;
                case 'down':
                    newRoom.y = currentRoom.y - 1;
                    break;
                case 'left':
                    newRoom.x = currentRoom.x - 1;
                    break;
                case 'right':
                    newRoom.x = currentRoom.x + 1;
                    break;
            }
            
            // Validate the new room is a valid branch
            if (!isValidRoom(newRoom)) {
                transitioning = false;
                return;
            }
            
            // Load or generate room state
            const roomKey = getRoomKey(newRoom);
            if (!roomMemory[roomKey]) {
                roomMemory[roomKey] = generateRoomState(newRoom);
            }
            
            // Update current room
            currentRoom = newRoom;
            
            // Load the room (this will restore its saved state)
            loadRoom(currentRoom);
            updateMap();
            updateRoomDisplay();
            
            // Position dragon on the clear path at the entry point
            const caveBackground = document.querySelector('.cave-background');
            if (caveBackground) {
                const caveWidth = caveBackground.offsetWidth;
                const caveHeight = caveBackground.offsetHeight;
                
                // Get the room's clear path
                const room = roomMemory[roomKey];
                const clearPath = room ? room.clearPath : null;
                
                let spawnX, spawnY;
                
                if (clearPath) {
                    // Spawn on the clear path at the entry end
                    if (clearPath.type === 'lshape' && clearPath.segments && clearPath.segments.length > 0) {
                        // L-shaped path: spawn on first segment at entry end
                        const firstSegment = clearPath.segments[0];
                        if (firstSegment.type === 'vertical') {
                            // First segment is vertical: spawn at entry end based on direction
                            spawnX = firstSegment.x; // Use the segment's X position (percentage)
                            if (direction === 'up') {
                                // Entered from bottom, spawn at bottom of path
                                spawnY = 30; // Near bottom edge
                            } else if (direction === 'down') {
                                // Entered from top, spawn at top of path
                                spawnY = caveHeight - 110; // Near top edge
                            } else {
                                // Default to bottom of segment
                                spawnY = firstSegment.minY + 30;
                            }
                        } else if (firstSegment.type === 'horizontal') {
                            // First segment is horizontal: spawn at entry end based on direction
                            spawnY = firstSegment.y; // Use the segment's Y position (pixels from bottom)
                            if (direction === 'right') {
                                // Entered from left, spawn at left of path
                                spawnX = 5; // Near left edge
                            } else if (direction === 'left') {
                                // Entered from right, spawn at right of path
                                spawnX = 95; // Near right edge
                            } else {
                                // Default to left of segment
                                spawnX = firstSegment.minX + 2;
                            }
                        } else {
                            // Unknown segment type - use default
                            spawnX = 50;
                            spawnY = 100;
                        }
                    } else if (clearPath.type === 'vertical') {
                        // Vertical path: spawn at entry end based on direction
                        spawnX = clearPath.x; // Use the path's X position (percentage)
                        if (direction === 'up') {
                            // Entered from bottom, spawn at bottom of path
                            spawnY = 30; // Near bottom edge
                        } else if (direction === 'down') {
                            // Entered from top, spawn at top of path
                            spawnY = caveHeight - 110; // Near top edge
                        } else {
                            // Default to center of path
                            spawnY = caveHeight / 2;
                        }
                    } else if (clearPath.type === 'horizontal') {
                        // Horizontal path: spawn at entry end based on direction
                        spawnY = clearPath.y; // Use the path's Y position (pixels from bottom)
                        if (direction === 'right') {
                            // Entered from left, spawn at left of path
                            spawnX = 5; // Near left edge
                        } else if (direction === 'left') {
                            // Entered from right, spawn at right of path
                            spawnX = 95; // Near right edge
                        } else {
                            // Default to center of path
                            spawnX = 50;
                        }
                    } else {
                        // Unknown path type - use default
                        spawnX = 50;
                        spawnY = 100;
                    }
                } else {
                    // No clear path (main room) - use default spawn
                    spawnX = 50;
                    spawnY = 100;
                }
                
                // Check for collision and find a safe spawn position
                const safePosition = findSafeSpawnPosition(spawnX, spawnY, direction, caveWidth, caveHeight);
                dragonPosition.x = safePosition.x;
                dragonPosition.y = safePosition.y;
            }
            
            updateDragonPosition();
            
            // Reset transition flag after a short delay
            setTimeout(function() {
                transitioning = false;
            }, 500);
        }

        function getRoomName(roomCoord) {
            // Return "Main Room" for the starting room (0,0)
            if (roomCoord.x === 0 && roomCoord.y === 0) {
                return 'Main Room';
            }
            return `Room (${roomCoord.x}, ${roomCoord.y})`;
        }

        function updateRoomDisplay() {
            const dragonNameElement = document.getElementById('adventure-dragon-name');
            if (dragonNameElement && currentDragon) {
                const roomName = getRoomName(currentRoom);
                dragonNameElement.textContent = `${currentDragon.name} - ${roomName}`;
            }
        }

        function updateMap() {
            const mapGrid = document.getElementById('room-map-grid');
            if (!mapGrid) return;

            // Clear existing map
            mapGrid.innerHTML = '';

            // Create 7x7 grid (from -3 to +3 in both directions)
            // Note: Grid is displayed with Y inverted (top row is highest Y)
            // Only show rooms that are branches from main room (on axes)
            for (let y = MAX_ROOMS; y >= -MAX_ROOMS; y--) {
                for (let x = -MAX_ROOMS; x <= MAX_ROOMS; x++) {
                    const roomCoord = { x: x, y: y };
                    
                    // Only show valid rooms (branches from main room)
                    if (!isValidRoom(roomCoord)) {
                        // Create empty cell for invalid rooms
                        const cell = document.createElement('div');
                        cell.className = 'room-map-cell unreachable';
                        cell.textContent = '';
                        cell.title = '';
                        mapGrid.appendChild(cell);
                        continue;
                    }
                    
                    const cell = document.createElement('div');
                    const roomKey = getRoomKey(roomCoord);
                    const isVisited = roomMemory[roomKey] && roomMemory[roomKey].visited;
                    const isCurrent = currentRoom.x === x && currentRoom.y === y;
                    const roomName = getRoomName(roomCoord);

                    cell.className = 'room-map-cell';
                    
                    if (isCurrent) {
                        cell.classList.add('current');
                        cell.textContent = '';
                        cell.title = `Current: ${roomName}`;
                    } else if (isVisited) {
                        cell.classList.add('visited');
                        cell.textContent = '';
                        cell.title = `Visited: ${roomName}`;
                    } else {
                        cell.textContent = '';
                        cell.title = roomName;
                    }

                    mapGrid.appendChild(cell);
                }
            }
        }

        // Joystick functions
        function showJoystick() {
            joystickContainer = document.getElementById('joystick-container');
            if (joystickContainer) {
                joystickContainer.style.display = 'block';
                joystickBase = joystickContainer.querySelector('.joystick-base');
                joystickStick = joystickContainer.querySelector('.joystick-stick');
                setupJoystickControls();
            }
        }

        function hideJoystick() {
            joystickContainer = document.getElementById('joystick-container');
            if (joystickContainer) {
                joystickContainer.style.display = 'none';
                joystickState = { active: false, x: 0, y: 0 };
                if (joystickStick) {
                    joystickStick.style.transform = 'translate(-50%, -50%)';
                }
            }
        }

        function setupJoystickControls() {
            if (!joystickBase || !joystickStick) return;

            let touchId = null;

            // Touch start
            joystickBase.addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (touchId !== null) return;
                
                const touch = e.touches[0];
                touchId = touch.identifier;
                joystickState.active = true;
                joystickContainer.classList.add('active');
                updateJoystickPosition(touch);
            });

            // Touch move
            joystickBase.addEventListener('touchmove', function(e) {
                e.preventDefault();
                if (touchId === null) return;
                
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === touchId) {
                        updateJoystickPosition(e.touches[i]);
                        break;
                    }
                }
            });

            // Touch end
            joystickBase.addEventListener('touchend', function(e) {
                e.preventDefault();
                let touchEnded = false;
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchId) {
                        touchEnded = true;
                        break;
                    }
                }
                
                if (touchEnded) {
                    touchId = null;
                    joystickState.active = false;
                    joystickState.x = 0;
                    joystickState.y = 0;
                    joystickContainer.classList.remove('active');
                    joystickStick.style.transform = 'translate(-50%, -50%)';
                }
            });

            // Also handle touch cancel
            joystickBase.addEventListener('touchcancel', function(e) {
                e.preventDefault();
                touchId = null;
                joystickState.active = false;
                joystickState.x = 0;
                joystickState.y = 0;
                joystickContainer.classList.remove('active');
                joystickStick.style.transform = 'translate(-50%, -50%)';
            });
        }

        function updateJoystickPosition(touch) {
            if (!joystickBase || !joystickStick) return;

            const rect = joystickBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const radius = rect.width / 2;

            // Calculate distance from center
            // Note: Invert Y axis so that moving finger UP gives positive Y (for up movement)
            const deltaX = touch.clientX - centerX;
            const deltaY = centerY - touch.clientY; // Inverted: centerY - touch.clientY
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // Limit stick movement to joystick base radius
            let stickX = deltaX;
            let stickY = deltaY;
            
            if (distance > radius - 35) { // 35 is half the stick size
                const angle = Math.atan2(deltaY, deltaX);
                stickX = Math.cos(angle) * (radius - 35);
                stickY = Math.sin(angle) * (radius - 35);
            }

            // Update stick visual position
            // For visual, we need to invert Y back to screen coordinates
            joystickStick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${-stickY}px))`;

            // Normalize joystick input (-1 to 1)
            // Y is already inverted for game logic (positive = up)
            joystickState.x = stickX / (radius - 35);
            joystickState.y = stickY / (radius - 35);
        }
    </script>
</body>
</html>
